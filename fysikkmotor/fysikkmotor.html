<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="nb" xml:lang="nb">
<head>
<!-- 2020-12-03 Thu 15:48 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fysikkmotor</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Tarjei Bærland" />
<link rel="stylesheet" type="text/css" href="./style.css" />
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Fysikkmotor</h1>
<p>
Gjennom dette oppgavearket skal vi lage en fysikkmotor ved å bruke Python og Pygame. Vi kommer omtrentlig til å ha en gjennomgang som følger
</p>
<dl class="org-dl">
<dt><a href="#vektorer">Vektorer</a></dt><dd>Hvordan kan vi representerere vektorer i et python-program?</dd>
<dt><a href="#partikler">Partikler</a></dt><dd>Kan vi samle flere egenskaper enn bare tall til i én verdi?</dd>
<dt><a href="#org21d3cdd">Simulering</a></dt><dd>Trinnvis framover i Pygame</dd>
<dt><a href="fysikkmotor.html#ID-050ff933-d1a8-4d9b-8be9-ef5dc351ef1b">Kollisjoner</a></dt><dd>Kan partiklene våre kollidere med hverandre?</dd>
<dt><a href="fysikkmotor.html#ID-f55222e8-5b25-4fce-aad3-f66217831d2c">Bugfikser</a></dt><dd>Utbedringer kommer til å være nødvendig.</dd>
<dt><a href="fysikkmotor.html#ID-fd134f56-3103-448a-ae32-4e7679b7e50e">Utforsking</a></dt><dd>Hvilke andre modeller kan vi bruke partiklene våre til?</dd>
</dl>

<p>
Motoren kommer til å ta form av en virtuell kasse som det spretter partikler rundt inni. Denne kan vi forhåpentligvis bruke til å gjennomføre ulike modelleringsforsøk.
</p>

<div id="outline-container-vektorer" class="outline-2">
<h2 id="vektorer">Vektorer</h2>
<div class="outline-text-2" id="text-vektorer">
<p>

</p>
</div>

<div id="outline-container-orgdcc3f33" class="outline-3">
<h3 id="orgdcc3f33">Introduksjon</h3>
<div class="outline-text-3" id="text-orgdcc3f33">
<p>
Fra matematikken kjenner vi en vektor som noe med størrelse og retning. Ofte illustrerer vi dette med en pil. Under vises vektoren \(\vec{v}\) tegnet som en pil i planet.
</p>


<div id="org4d10921" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 1 </span>En vektor illustrert som en pil</p>
</div>

<p>
En vektor avhenger ikke av hvor vi tegner den, kun av dens størrelse og retning, altså vil disse to vektorene være den samme, til tross for at de er «ved siden av hverandre».
</p>


<div id="org8bac353" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 2 </span>To like vektorer, altså to av den samme vektoren</p>
</div>

<p>
Dette er altså tilsvarende at tallet 3 er tallet 3, uavhengig av hvor vi møter det.
</p>

<p>
Før vi kan representere en vektor i et dataprogram, må vi bestemme oss for hvordan vi ønsker å <i>representere</i> vektoren. Vi kan for eksempel se for oss vektoren \(\vec{v}\) som en pil, hvor lengden til \(\vec{v}\), den såkalte <i>absoluttverdien</i>, er \(|\vec{v}| = 3\) og vinkelen mellom \(\vec{v}\) og en horisontalakse er \(\theta = 30^{\circ}\).
</p>


<div id="orgdc1d530" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor3.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 3 </span>En vektor, dens størrelse og dens retning</p>
</div>

<p>
Om vi så ønsker å representere dette i et python-program, kan vi for eksempel skrive
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">absoluttverdi</span> = 3
<span class="org-variable-name">vinkel</span> = 30
</pre>
</div>

<p>
Dette byr på en serie problemer, blant annet at vi nå har to variabler for å holde styr på det som strengt tatt bare er én matematisk størrelse, vektoren \(\vec{v}\).
</p>

<div class="task" id="org839ac44">
<p>
Om du allerede kjenner til vektorer, stopp opp her og tenk på hvordan du ville representert dem i kode.
</p>

</div>
</div>
</div>

<div id="outline-container-org185889a" class="outline-3">
<h3 id="org185889a">Addisjon</h3>
<div class="outline-text-3" id="text-org185889a">
<p>
Vi er vant til at \(\text{tall} + \text{tall} = \text{tall}\) og at \(\text{tall} \cdot \text{tall} = \text{tall}\).
</p>

<p>
For vektorer er addisjon som forventet, \(\text{vektor} + \text{vektor} = \text{vektor}\). For å visualisere en vektorsumm, kan vi sette de to vektorleddene etter hverandre. Under vises \(\vec{u}\) og \(\vec{v}\).
</p>


<div id="orge3c4199" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor4.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 4 </span>To vektorer</p>
</div>

<p>
For å legge disse sammen visuelt, kan vi sette de etter hverandre, slik at \(\vec{v}\) starter der \(\vec{u}\) slutter. Summen \(\vec{u} + \vec{v}\) er da en <i>ny vektor</i> som starter der \(\vec{u}\) starter og slutter der \(\vec{v}\) slutter.
</p>


<div id="orgd0ad63a" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor5.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 5 </span>Vektorsum</p>
</div>

<p>
Essensen her er at summen av to vektorer er en ny vektor.
</p>

<div class="task" id="orga957d2a">
<p>
Om vi har to vektorer representert som to lengder og to vinkler, à la det beskrevet tidligere. Hvordan kan vi gå fram for å finne vektorsummen av disse?
</p>

</div>
</div>
</div>

<div id="outline-container-org52dbae2" class="outline-3">
<h3 id="org52dbae2">Dekomponering</h3>
<div class="outline-text-3" id="text-org52dbae2">
<p>
Vi <i>dekomponerer</i> en vektor ved å skrive den som en sum av vektorer, vi finner dens <i>komponenter</i>. Det vanligste er å la hver av disse komponentene ligge langs en koordinatakse. Under har vi dekomponert \(\vec{v}\) til en vektor i \(x\)-retning, \(\vec{v}_x\) og en vektor i \(y\)-retning, \(\vec{v}_y\).
</p>


<div id="org6389874" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor6.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 6 </span>Dekomponering</p>
</div>

<p>
Merk at de to vektorene \(\vec{v}_x\) og \(\vec{v}_y\) er de <i>eneste</i> to vektorene i \(x\)- og \(y\)-retning hvor summen gir \(\vec{v}\), altså er \(\vec{v}\) <i>entydig</i> bestemt av de to vektorene. Om vi da skriver \(|\vec{v}_x| = v_x\) og \(|\vec{v}_y| = v_y\), kan vi samle det hele til \[\vec{v} = \left[v_x, v_y\right].\]
</p>

<p>
Vi sier at vi nå har skrevet \(\vec{v}\) på <i>koordinatform</i>. For eksempel, dersom vi har \(\vec{v}\) som definert over, vil vi få
</p>

\begin{aligned}
\vec{v} &= \left[|\vec{v}_x|, |\vec{v}_y|\right] \\
        &= \left[|\vec{v}| \cos 30^{\circ}, |\vec{v}| \sin 30^{\circ} \right] \\
        &= \left[3\cdot \tfrac{\sqrt{3}}{2}, 3\cdot\tfrac{1}{2} \right] \\
        &= \left[\tfrac{3\sqrt{3}}{2}, \tfrac{3}{2} \right].
\end{aligned}

<div class="task" id="orgda04cc8">
<p>
Hvordan kan vi representerer vektorer på koordinatform i et program?
</p>

</div>
</div>
</div>

<div id="outline-container-org1c76af6" class="outline-3">
<h3 id="org1c76af6">Omforming</h3>
<div class="outline-text-3" id="text-org1c76af6">
<p>
Vektorer på koordinatform har en annen fin egenskap, summen av to vektorer er den komponentvise summen av leddene. Altså er
</p>

\begin{aligned}
\vec{u} + \vec{v} &= \left[u_x, u_y\right] + \left[v_x, v_y\right] \\
                  &= \left[u_x + v_x, u_y + v_y\right].
\end{aligned}

<p>
Merk at også når vi ønsker å representere vektorer på koordinatform med tall, trenger vi to tall om vektoren er i to dimensjoner (i planet). Det ser ut som at uansett hvordan vi representerer vektorer med tall, trenger vi like mange tall som vi har dimensjoner for vektoren.
</p>

<p>
Naivt kunne vi tenkt at vi skulle representert vektoren på en form à la
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">x_koordinat</span> = 2.598  <span class="org-comment-delimiter"># </span><span class="org-comment">3 * cos(30 grader)</span>
<span class="org-variable-name">y_koordinat</span> = 1.500  <span class="org-comment-delimiter"># </span><span class="org-comment">3 * sin(30 grader)</span>
</pre>
</div>

<div class="task" id="org9e7ab9d">
<p>
Lag et program som tar inn en vektor med lengde og vinkel, og returnerer en vektor på koordinatform. Du kan for eksempel lage det som en funksjon på formen
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">polar_til_koordinat</span>(lengde, vinkel):
    <span class="org-comment-delimiter"># </span><span class="org-comment">dine utregninger</span>
    <span class="org-keyword">return</span> [x_koordinat, y_koordinat]
</pre>
</div>

<p>
Legg merke til her at vi har valgt å representere vektoren på koordinatform som en liste. Dette er fordi vi ikke kan ha en funksjon i python som returerner to uavhengige verdier uten at disse pakkes sammen på et vis.
</p>

</div>

<div class="task" id="org1c5d7d6">
<p>
Skriv et program som regner ut summen av de to vektorene under. Kall svaret ditt <code>w</code>.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">u</span> = [1, 3]
<span class="org-variable-name">v</span> = [4, 5]
</pre>
</div>

</div>

<div class="task" id="org7e5703b">
<p>
Skriv en funksjon som tar inn en vektor på koordinatform, da som en liste av to verdier, og returnerer en liste med vektorens <code>lengde</code> og <code>vinkel</code>. Du kan kalle funksjonen <code>koordinat_til_polar</code>.
</p>

</div>
</div>
</div>

<div id="outline-container-org0c77630" class="outline-3">
<h3 id="org0c77630">Representasjonsform</h3>
<div class="outline-text-3" id="text-org0c77630">
<p>
Vi har nå sett at det matematisk finnes ulike ekvivalente måter å representere en vektor på, som et sett av lengde og vinkel, som \(x\)- og \(y\)-koordinater, og vi kunne tenkt oss mange flere (de fleste av dem uhensiktsmessige i de fleste tilfeller, som et sett av lengde og en \(x\)-koordinat).
</p>

<p>
Vi begynner også å ane konturene av at det er uendelig mange måter å representere vektorer i dataprogrammer, som enkeltvariabler, som en liste, og som andre «sammensatte datatyper».
</p>

<p>
Under oppgaven med vektoraddisjon, så vi dog at listerepresentasjonen, om enn den samler vektoren til ett format, ikke er hensiktsmessig for addisjon. Et bedre alternativ da er å bruke et <code>numpy-array</code>. Vi får dette ved å skrive for eksempel
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np

<span class="org-variable-name">u</span> = np.array([2.598, 1.500])  <span class="org-comment-delimiter"># </span><span class="org-comment">3 * sin(30 grader)</span>
</pre>
</div>

<div class="task" id="org81965c1">
<p>
Forsøk å se hvordan addisjon av vektorer fungerer nå. Start med en vektor <code>u</code> og en vektor <code>v</code>, hver representert som et numpy-array, og test ut addisjon ved å bruke et vanlig <code>+</code>-tegn.
</p>

<p>
Hva observerer du?
</p>

<p>
Test det samme om de to vektorene hadde vært lister.
</p>

<p>
Kommenter svarene dine.
</p>

</div>
</div>
</div>

<div id="outline-container-orgdeb9c93" class="outline-3">
<h3 id="orgdeb9c93">Skalarproduktet</h3>
<div class="outline-text-3" id="text-orgdeb9c93">
<p>
Vi har sett at addisjon fungerer som vi forventer mellom vektorer, en sum av to vektorer er en ny vektor. Hva med multiplikasjon?
</p>

<p>
Vel. For vektorer operer vi gjerne med <i>to</i> typer multiplikasjon, et såkalt <i>skalarprodukt</i> og et <i>vektorprodukt</i>. Vi noterer det som \(\vec{u}\cdot\vec{v}\) for skalarproduktet og \(\vec{u}\times\vec{v}\). Det overraskende her er at <i>skalarproduktet</i> tar inn to vektorer og gir ut et tall (en skalar), mens vektorproduktet tar inn to vektorer og gir ut en vektor.
</p>

<p>
Inntil videre er det kun skalarproduktet vi skal ta hensyn til.
</p>

<p>
På samme måte som at det finnes ulike måter å tenke på vektorer, finnes det ulike måter å tenke på skalarproduktet. En av disse er å si at « \(\vec{u}\cdot\vec{v}\) er lengden av \(\vec{u}\) ganget med lengden av den delen av \(\vec{v}\) som ligger langs \(\vec{u}\)».
</p>

<p>
«Den delen av \(\vec{v}\) som ligger langs \(\vec{u}\)» er illustert under. Om vi lar \(\vec{u}\) og \(\vec{v}\) starte i samme punkt, og trekker enden av \(\vec{v}\) «loddrett ned på \(\vec{u}\)» får vi delen av \(\vec{v}\) som ligger langs \(\vec{u}\) som \(\vec{v}_u\). Dette er vist under.
</p>


<div id="org3c9155b" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor7a.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 7 </span>\(\vec{v}_u\) er delen av \(\vec{v}\) som ligger langs \(\vec{u}\)</p>
</div>

<p>
Lengden av \(\vec{v}_u\) da skrives \(|\vec{v}|\cos\theta\), som enklere vises om vi orienterer oss slik at \(\vec{u}\) ligger langs horisontalaksen.
</p>


<div id="org7917b17" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor7a1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 8 </span>Lengden av \(\vec{v}_u\)</p>
</div>

<p>
Vi sier at vi har funnet <i>projeksjonen</i> av \(\vec{v}\) på \(\vec{u}\), \(\vec{v}_u\).
</p>

<p>
Kan vi med dette få en intuisjon av hva \(\vec{u}\cdot\vec{v}\) er?
</p>

<p>
Ja, \(\vec{u}\cdot\vec{v}\) er «lengden av \vec{u} ganget med lengden av \(\vec{v}_u\)». Altså har vi at \(\vec{u}\cdot\vec{v} = |\vec{u}||\vec{v}_u|\).
</p>

<div class="task" id="org7a68df5">
<p>
Lag et program som tar inn to vektorer, \(u\) og \(v\) (du kan bruke de samme som i eksempelet over). Regn ut \(\vec{u}\cdot\vec{v}\) ved å bruke at \[\vec{u}\cdot\vec{v} = |\vec{u}||\vec{v}|\cos \theta,\] hvor \(\theta\) er vinkelen mellom \(\vec{u}\) og \(\vec{v}\).
</p>

</div>

<p>
Om vi har vektorene representert på koordinatform, er det en enkel sak å regne ut skalarproduktet. Vi kan da bruke at 
</p>

\begin{aligned}
\vec{u}\cdot\vec{v} &= \left[u_x, u_y\right]\cdot\left[v_x, v_y\right] \\
                    &= u_x v_x + u_y v_y
\end{aligned}

<div class="task" id="org70c3c2e">
<p>
Lag et program som tar inn to vektorer på koordinatform i lister. Regn ut vektorenes skalarprodukt ved å bruke definisjonen over.
</p>

<p>
Du kan for eksempel ta utgangspunkt i følgende:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">u</span> = [-5, 8]
<span class="org-variable-name">v</span> = [-3, 1]
</pre>
</div>

</div>

<p>
Skalarproduktet oppstår i mange områder av matematikken. I <code>numpy</code> har vi det innebygd som <code>dot</code>-funksjonen. For eksempel vil <code>np.dot(a, b)</code> regne ut skalarproduktet (eller «prikkproduktet» eller «dotproduktet») til de to vektorene <code>a</code> og <code>b</code>.
</p>

<div class="task" id="org845d222">
<p>
Lag et program som tar inn to vektorer på koordinatform i numpy-arrayer. Regn ut vektorenes skalarprodukt ved å bruke <code>np.dot</code>.
</p>

<p>
Du kan for eksempel ta utgangspunkt i følgende:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">u</span> = np.array([-5, 8])
<span class="org-variable-name">v</span> = np.array([-3, 1])
</pre>
</div>

</div>
</div>
</div>

<div id="outline-container-orgdbaedde" class="outline-3">
<h3 id="orgdbaedde">Skalering eller skalarmultiplikasjon</h3>
<div class="outline-text-3" id="text-orgdbaedde">
<p>
Ordet «skalar» brukes ofte om tall i vektorsammenheng. Bakgrunnen for dette navnet er nettopp at et tall multiplisert med en vektor gir en <i>skalert</i> vektor. Vi kan bruke ordene «skalar» og «tall» om hverandre.
</p>

<p>
En vektor \(\vec{v}\) skalert med et tall \(t\) er en ny vektor med samme retning som \(\vec{v}\) og lengde \(t|\vec{v}|\).
</p>


<div id="orgb79f89d" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor8.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 9 </span>Skalerte vektorer</p>
</div>

<p>
Her er \(0 < a < 1\), \(b > 1\) og \(c < 0\). Vi ser altså at en negativ skalering av en vektor gir en vektor med motsatt retning. For eksemplene i figuren over, er \(|b| = |c|\).
</p>

<div class="task" id="org4db95a4">
<p>
Undersøk om <code>np.dot(t, v)</code> fungerer som forventet dersom <code>t</code> er et tall og <code>v</code> er en vektor i form av et numpy-array.
</p>

</div>
</div>
</div>
</div>

<div id="outline-container-partikler" class="outline-2">
<h2 id="partikler">Partikler</h2>
<div class="outline-text-2" id="text-partikler">
<p>

</p>
</div>

<div id="outline-container-org042a1b6" class="outline-3">
<h3 id="org042a1b6">Introduksjon</h3>
<div class="outline-text-3" id="text-org042a1b6">
<p>
Vi skal ha partikler sprettende rundt på en skjerm. Vi bør da kunne ha en måte i programmet vårt for å si «dette er en bestemt partikkel». Ideelt sett kunne for eksempel <code>partikkel_1</code> vist til en partikkel med en posisjon, fart, størrelse, og <code>partikkel_2</code> det samme.
</p>


<div id="org8f5793e" class="figure">
<p><object type="image/svg+xml" data="figurer/partikkel1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 10 </span>To ulike partikler, <code>partikkel_1</code> og <code>partikkel_2</code></p>
</div>

<p>
Her ser vi at det som skiller <code>partikkel_1</code> og <code>partikkel_2</code> er deres <i>posisjon</i>, <i>mønster</i>, og <i>størrelse</i>. Vi må altså nok en gang gjøre et valg for hvordan vi skal representere partiklene i kode.
</p>

<p>
La oss si vi velger å ha <i>posisjon</i> som en liste med \(x\)- og \(y\)-verdier, <i>mønster</i> som en tekststreng (for eksempel <code>"stripete"</code> og <code>"prikkete"</code> og størrelse som et tall. Vi kunne da bestemt oss for at de to partiklene over var definert som
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">partikkel_1</span> = [[38.6, 8.6], <span class="org-string">"stripete"</span>, 13.5]
<span class="org-variable-name">partikkel_2</span> = [[87.3, -12.9], <span class="org-string">"prikkete"</span>, 8.3]
</pre>
</div>

<p>
Vi kan da fortelle de som skal bruke programmet at «en partikkel er en liste med tre verdier, den første verdien er en liste med koordinater, den andre en tekststreng som setter mønsteret, den tredje et tall for radiusen».
</p>

<div class="task" id="org6c9dd89">
<p>
Lag en <code>partikkel_3</code>, med radius 15.3, senter i origo og rutete mønster.
</p>

</div>

<p>
Python har en annen god datatype for å samle slike egenskaper, såkalte <i>dictionaries</i> eller ordbøker. Dette er en samling med nøkkelord og verdier. Om vi skulle oppgitt partiklene over som ordbøker, ville vi skrevet
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">partikkel_1</span> = {<span class="org-string">"posisjon"</span>: [38.6, 8.6],
               <span class="org-string">"m&#248;nster"</span>: <span class="org-string">"stripete"</span>,
               <span class="org-string">"radius"</span>: 13.5}
</pre>
</div>

<p>
Vi skriver altså <code>{}</code> med en samling av <code>nøkkelord: verdi,</code> mellom. Vi kan da hente ut verdier ved å skrive for eksempel <code>partikkel_1["radius"]</code> eller legge til nye verdier ved å skrive <code>partikkel_1["masse"] = 14</code>.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">print</span>(partikkel_1[<span class="org-string">"radius"</span>])
<span class="org-variable-name">partikkel_1</span>[<span class="org-string">"masse"</span>] = 14
<span class="org-keyword">print</span>(partikkel_1)
</pre>
</div>

<pre class="example" id="org29972af">
13.5
{'posisjon': [38.6, 8.6], 'mønster': 'stripete', 'radius': 13.5, 'masse': 14}
</pre>

<div class="task" id="orga0b69ab">
<p>
Lag <code>partikkel_1</code> og <code>partikkel_2</code> som over, men gjør posisjonen til et numpy-array, istedenfor lista vi bruker over.
</p>

</div>
</div>
</div>

<div id="outline-container-orgcda6319" class="outline-3">
<h3 id="orgcda6319">Tegne partikkel</h3>
<div class="outline-text-3" id="text-orgcda6319">
<p>
Dette avsnittet forutsetter at du har lagt inn biblioteket <code>pygame</code>. Dette kan du gjøre ved å åpne programmet «Anaconda prompt» og kjøre kommandoen <code>pip install pygame</code>.
</p>

<p>
Pygame er et bibliotek som egentlig er ment for spill, men vi kan med hell bruke det for å visualisere fysikkmotoren vår òg.
</p>

<p>
De fleste spill følger en løkke som ser omtrent slikt ut:
</p>
<ol class="org-ol">
<li>Vi prosesserer data fra brukeren (tastetrykk, musebevegelser, stenge vinduet, osv.)</li>
<li>Spillmotoren oppdaterer spillet (partikler flyttes, lyder gjøres klare til å spilles av, osv.)</li>
<li>Et nytt bilde tegnes på skjermen (nye partikkelposisjoner, for eksempel.)</li>
</ol>

<p>
Før dette må vi initialisere hele «spillet».
</p>


<div id="orgc451947" class="figure">
<p><object type="image/svg+xml" data="figurer/flytskjema1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 11 </span>Flytskjema for hele «spillet» vårt</p>
</div>
</div>

<div id="outline-container-org9a53b0b" class="outline-4">
<h4 id="org9a53b0b">«Init» og oppsett</h4>
<div class="outline-text-4" id="text-org9a53b0b">
<p>
Her skal vi gjøre <code>pygame</code> klart.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> pygame

pygame.init()
<span class="org-variable-name">flate</span> = pygame.display.set_mode((800, 600))

<span class="org-comment-delimiter"># </span><span class="org-comment">Her kommer vi til &#229; skrive &#248;vrige funksjonsdefinisjoner</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">og lage variabler til programmet v&#229;rt</span>
</pre>
</div>

<p>
Vi har nå gjort pygame klart til å bruke et vindu som er 800 piksler bredt, og 600 piksler høyt. Det er dette vinduet vi skal tegne partiklene våre i.
</p>
</div>
</div>

<div id="outline-container-org6b10684" class="outline-4">
<h4 id="org6b10684">Hovedløkke og prosessere inndata</h4>
<div class="outline-text-4" id="text-org6b10684">
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">kjoerer</span> = <span class="org-constant">True</span>
<span class="org-keyword">while</span> kjoerer:
    <span class="org-keyword">for</span> event <span class="org-keyword">in</span> pygame.event.get():
        <span class="org-keyword">if</span> event.<span class="org-builtin">type</span> == pygame.QUIT:
            <span class="org-variable-name">kjoerer</span> = <span class="org-constant">False</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Her kommer &#171;mainloopen&#187; v&#229;r</span>

<span class="org-keyword">print</span>(<span class="org-string">"Simuleringen er ferdig."</span>)
pygame.<span class="org-constant">quit</span>()
</pre>
</div>

<pre class="example">
Simuleringen er ferdig.
</pre>


<p>
Denne snutten gjør klar en hovedløkke, og vi setter opp et trinn for å prosessere inndata. Pygame håndterer handlinger fra brukeren ved å samle dem som =event=s.
</p>

<p>
Vi får tak i alle disse hendelsene («event») ved å kalle funksjonen <code>pygame.EVENT.get</code>. Dette gir oss en liste med hendelser. Vi kan så løpe gjennom hver av disse hendelsene (det kan for eksempel være flyttinga av musepekeren, trykking av knapper, osv.).
</p>

<p>
Dersom du har forsøkt å lukke pygame-vinduet, har en av hendelsene vært av typen <code>pygame.QUIT</code>. Vi sier da at dersom en av hendelsen var <code>pygame.QUIT</code> skal vi ut av hovedløkka, som vi her har valgt å gjøre ved å sette <code>kjoerer</code> til <code>False</code>.
</p>

<p>
Når vi da har kommet oss helt ut av hovedløkka vår (<code>while kjoerer</code>-blokka), stenger vi pygame ved å kalle <code>quit</code>-funksjonen.
</p>
</div>
</div>

<div id="outline-container-org2944d68" class="outline-4">
<h4 id="org2944d68">Oppdatere spilldata</h4>
<div class="outline-text-4" id="text-org2944d68">
<p>
Det har ikke skjedd så mye med partiklene våre ennå.
</p>

<p>
Om vi lager en partikkel som over, med
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">partikkel</span> = {<span class="org-string">"posisjon"</span>: [38.6, 8.6],
             <span class="org-string">"farge"</span>: (0, 14, 200),
             <span class="org-string">"radius"</span>: 14}
</pre>
</div>

<p>
kan vi nå late som at vi gjør noe med partikkelens posisjon hver gang gjennom løkka ved for eksempel å skrive
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> pygame

pygame.init()
<span class="org-variable-name">flate</span> = pygame.display.set_mode((800, 600))

<span class="org-variable-name">partikkel</span> = {<span class="org-string">"posisjon"</span>: [38.6, 8.6],
             <span class="org-string">"farge"</span>: (100, 14, 200),  <span class="org-comment-delimiter"># </span><span class="org-comment">rgb-verdi</span>
             <span class="org-string">"radius"</span>: 14}


<span class="org-variable-name">kjoerer</span> = <span class="org-constant">True</span>
<span class="org-keyword">while</span> kjoerer:
    <span class="org-keyword">for</span> event <span class="org-keyword">in</span> pygame.event.get():
        <span class="org-keyword">if</span> event.<span class="org-builtin">type</span> == pygame.QUIT:
            <span class="org-variable-name">kjoerer</span> = <span class="org-constant">False</span>

    <span class="org-variable-name">partikkel</span>[<span class="org-string">"posisjon"</span>] = [38.6, 8.6]   <span class="org-comment-delimiter"># </span><span class="org-comment">Obs! Denne gj&#248;r ikke noe</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">!</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">!</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">! Se under</span>
    flate.fill((0, 0, 0))
    pygame.draw.circle(flate, (214, 77, 238), [38.6, 8.6], 140)
    pygame.display.flip()

<span class="org-keyword">print</span>(<span class="org-string">"Simuleringen er ferdig."</span>)
pygame.<span class="org-constant">quit</span>()
</pre>
</div>

<pre class="example">
Simuleringen er ferdig.
</pre>


<p>
Vi har dog fremdeles ikke en partikkel på skjermen. Dette kan vi fikse ved først å tegne en bakgrunn, for så å tegne en sirkel.
</p>

<p>
Om du erstatter de tre linjene med <code># !</code> med de følgende tre linjene, skal du nå få en partikkel opp på skjermen.
</p>

<div class="org-src-container">
<pre class="src src-python">flate.fill((0, 0, 0))  <span class="org-comment-delimiter"># </span><span class="org-comment">bakgrunn</span>
pygame.draw.circle(flate, (0, 14, 200), [38.6, 8.6], 14) <span class="org-comment-delimiter"># </span><span class="org-comment">partikkel</span>
pygame.display.flip()  <span class="org-comment-delimiter"># </span><span class="org-comment">sender alt til flaten</span>
</pre>
</div>

<p>
Vi kjører koden og får følgende:
</p>


<div id="org470feec" class="figure">
<p><img src="figurer/partikkel_pygame.png" alt="partikkel_pygame.png" />
</p>
<p><span class="figure-number">Illustrasjon 12 </span>Vår første partikkel</p>
</div>

<p>
Vi merker oss at posisjonen var i et annet hjørne enn forventet, men lar det være med det inntil videre.
</p>

<div class="task" id="orgdfd2ce2">
<p>
Du har lagt merke til at vi har vært uelegente med hvordan vi henter ut data fra partikkelen vår. Når vi tegner den, skriver vi for eksempel <code>(0, 14, 200)</code> for fargen, istedenfor <code>partikkel["farge"]</code>.
</p>

<p>
Fiks opp i dette slik at de ulike tallene kun står en gang i programmet.
</p>

</div>

<div class="task" id="orgb3ec892">
<p>
For å sette farge på partikkelen, har vi gitt fargen som en samling av r(ød)-, g(rønn)-, og b(lå)-verdier.
</p>

<p>
Du kan bruke <a href="https://htmlcolorcodes.com/color-picker/">denne</a> siden til å finne noen farger du liker. Velg ulike farger for partikkelen og bakgrunnen.
</p>

</div>

<div class="task" id="orgd7c7a6e">
<p>
Bruk <code>randint</code>-funksjonen fra <code>random</code>-biblioteket til å gi partikkelen tilfeldig posisjon, farge og radius.
</p>

<p>
Hvordan kan du forsikre deg om at <i>hele</i> partikkelen alltid vises?
</p>

</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org21d3cdd" class="outline-2">
<h2 id="org21d3cdd">Simulering</h2>
<div class="outline-text-2" id="text-org21d3cdd">
<p>

</p>
</div>

<div id="outline-container-orga5add2c" class="outline-3">
<h3 id="orga5add2c">Introduksjon</h3>
<div class="outline-text-3" id="text-orga5add2c">
<p>
Vi skal nå begynne å flytte rundt på partikkelen vår, samtidig som vi ønsker å se endringen på skjermen.
</p>

<p>
Figuren under viser hvordan partikkelen <code>pt1</code> har flyttet seg fra en posisjon gitt med vektoren \(\vec{r}_a\) til en posisjon gitt ved \(\vec{r}_b\). Vi ser også noen plasseringer <code>pt1</code> hadde før den havnet ved \(\vec{r}_a\) og noen plasseringer mellom \(\vec{r}_a\) og \(\vec{r}_b\). Hvordan skal vi få representert dette i programmet vårt?
</p>


<div id="orgbe8ad61" class="figure">
<p><object type="image/svg+xml" data="figurer/simulering1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 13 </span>En partikkel <code>pt1</code> ved to ulike tidspunkter</p>
</div>
</div>
</div>

<div id="outline-container-orgda084b8" class="outline-3">
<h3 id="orgda084b8">Klokka</h3>
<div class="outline-text-3" id="text-orgda084b8">
<p>
I Pygame løser vi dette med en klokke. Under initialiseringa, kan vi opprette en klokke ved å skrive for eksempel <code>klokke = pygame.time.Clock()</code>. Dette er altså en linje hvor vi går inn i <i>modulen</i> <code>time</code> og lager oss en <code>Clock</code>. I resten av programmet vårt har vi nå muligheten til å gjøre ting med variabelen <code>klokke</code>.
</p>

<p>
Det viktigste vi kommer til å gjøre med klokka er å klikke den framover ved å bruke <code>tick</code>. Dette gjør vi én gang hver runde i hovedløkka vår.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> pygame

<span class="org-variable-name">klokke</span> = pygame.time.Clock()
<span class="org-builtin">help</span>(klokke.tick)
</pre>
</div>

<pre class="example" id="org005fa82">
pygame 2.0.0 (SDL 2.0.12, python 3.8.6)
Hello from the pygame community. https://www.pygame.org/contribute.html
Help on built-in function tick:

tick(...) method of builtins.Clock instance
    tick(framerate=0) -&gt; milliseconds
    update the clock
</pre>

<p>
<code>tick</code> er altså en funksjon som oppdaterer klokka vår og returnerer et antall millisekunder. Antallet millisekunder er hvor lang tid det er siden sist <code>tick</code> blei brukt.
</p>

<div class="task" id="orgfbb96cd">
<p>
Kjør følgende kode. Hvilken verdi har <code>dt</code> etter du har kjørt koden?
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> pygame

<span class="org-variable-name">klokke</span> = pygame.time.Clock()
klokke.tick()    <span class="org-comment-delimiter"># </span><span class="org-comment">her gir ikke antallet millisekunder siden forrige kall mening</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">La oss gj&#248;re en utregning</span>
<span class="org-variable-name">trekanttall_nr_million</span> = <span class="org-builtin">sum</span>(<span class="org-builtin">range</span>(1_000_001))
<span class="org-variable-name">dt</span> = klokke.tick()
</pre>
</div>

</div>

<div class="task" id="org589162c">
<p>
Funksjonen <code>sum(sekvens)</code> brukt over summerer en sekvens, og funksjonen <code>range(n)</code> gir en sekvens \((0, 1, \ldots, n)\).
</p>

<p>
Trekanttall nr. \(n\) er summen av alle tallene fra \(1\) til \(n\).
</p>

<p>
Hva gjør programmet i forrige oppgave?
</p>

</div>

<p>
I de fleste tilfeller kommer vi bare til å bruke <code>tick</code> på én linje i programmet, mot slutten av hovedløkka vår. Dersom vi gir <code>tick</code> parameteren <code>framerate</code>, vil Pygame forsøke å begrense hastigheten til programmet vårt slik at det tegner et gitt antall bilder i sekundet. Om vi ønsker 60 bilder i sekunder, skriver vi da <code>klokke.tick(60)</code>.
</p>

<p>
Etter tilpasningene våre fra tidligere, har vi nå et program som ser omtrent slik ut:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> pygame
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np

pygame.init()
<span class="org-variable-name">klokke</span> = pygame.time.Clock()

<span class="org-variable-name">flate</span> = pygame.display.set_mode((800, 600))
<span class="org-variable-name">pt</span> = {<span class="org-string">"posisjon"</span>: np.array([38.6, 8.6]),
      <span class="org-string">"farge"</span>: (100, 14, 200),  <span class="org-comment-delimiter"># </span><span class="org-comment">rgb-verdi</span>
      <span class="org-string">"radius"</span>: 14}


<span class="org-variable-name">kjoerer</span> = <span class="org-constant">True</span>
<span class="org-keyword">while</span> kjoerer:
    <span class="org-keyword">for</span> event <span class="org-keyword">in</span> pygame.event.get():
        <span class="org-keyword">if</span> event.<span class="org-builtin">type</span> == pygame.QUIT:
            <span class="org-variable-name">kjoerer</span> = <span class="org-constant">False</span>

    flate.fill((0, 0, 0))
    pygame.draw.circle(flate, pt[<span class="org-string">"farge"</span>], pt[<span class="org-string">"posisjon"</span>], pt[<span class="org-string">"radius"</span>])
    pygame.display.flip()
    klokke.tick(60)

<span class="org-keyword">print</span>(<span class="org-string">"Simuleringen er ferdig."</span>)
pygame.<span class="org-constant">quit</span>()
</pre>
</div>

<p>
Legg merke til at vi nå har gjort posisjonen om til et numpy-array og at vi bruker partikkelen <code>pt</code> direkte i tegningen av sirkelen vår.
</p>

<div class="task" id="org49c7e6b">
<p>
Skriv av koden over og kontroller at du får samme figur som tidligere.
</p>

</div>
</div>
</div>

<div id="outline-container-org437d37f" class="outline-3">
<h3 id="org437d37f">Dynamikk</h3>
<div class="outline-text-3" id="text-org437d37f">
<p>
I koden under har vi lagt til tre variabler for oppsettet vårt, som vi viser at vi ikke tenker å endre ved å skrive dem med bare store bokstaver, <code>BREDDE</code>, <code>HØYDE</code>, og <code>BAKGRUNNSFARGE</code>.
</p>

<p>
Det virkelig nye gjør vi dog på linja merket med <code># &lt;- Obs!</code>
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> pygame
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np

<span class="org-variable-name">BREDDE</span> = 800
<span class="org-variable-name">H&#216;YDE</span> = 600
<span class="org-variable-name">BAKGRUNNSFARGE</span> = (0, 0, 0)
pygame.init()
<span class="org-variable-name">klokke</span> = pygame.time.Clock()

<span class="org-variable-name">flate</span> = pygame.display.set_mode((BREDDE, H&#216;YDE))
<span class="org-variable-name">pt</span> = {<span class="org-string">"posisjon"</span>: np.array([38.6, 8.6]),
      <span class="org-string">"farge"</span>: (100, 14, 200),  <span class="org-comment-delimiter"># </span><span class="org-comment">rgb-verdi</span>
      <span class="org-string">"radius"</span>: 14}

<span class="org-variable-name">kjoerer</span> = <span class="org-constant">True</span>

<span class="org-keyword">while</span> kjoerer:
    <span class="org-keyword">for</span> event <span class="org-keyword">in</span> pygame.event.get():
        <span class="org-keyword">if</span> event.<span class="org-builtin">type</span> == pygame.QUIT:
            <span class="org-variable-name">kjoerer</span> = <span class="org-constant">False</span>

    <span class="org-variable-name">pt</span>[<span class="org-string">"posisjon"</span>] = pt[<span class="org-string">"posisjon"</span>] + np.array([1, 0])  <span class="org-comment-delimiter"># </span><span class="org-comment">&lt;- Obs!</span>
    flate.fill(BAKGRUNNSFARGE)
    pygame.draw.circle(flate, pt[<span class="org-string">"farge"</span>], pt[<span class="org-string">"posisjon"</span>], pt[<span class="org-string">"radius"</span>])
    pygame.display.flip()
    klokke.tick(60)

<span class="org-keyword">print</span>(<span class="org-string">"Simuleringen er ferdig."</span>)
pygame.<span class="org-constant">quit</span>()
</pre>
</div>

<p>
Når vi kjører koden får vi et vindu som ser omtrent slik ut, om enn litt større.
</p>


<div id="orgc439dd8" class="figure">
<p><img src="figurer/simulering_anim1.gif" alt="simulering_anim1.gif" />
</p>
<p><span class="figure-number">Illustrasjon 14 </span>En partikkel som beveger seg</p>
</div>

<p>
Her flytter vi altså partikkelen litt mellom hvert trykk på klokka. Vi gir partikkelen <code>pt</code> en ny posisjon, ved å bruke at vektorer kan legges sammen som numpy arrayer. Vi får da linja <code>pt["posisjon"] = pt["posisjon"] + np.array([1, 0])</code>. Vi øker altså partikkelens \(x\)-verdi med \(1\) hver gang gjennom hovedløkka.
</p>

<div class="task" id="org25d28fc">
<p>
Forsøk å bruke denne koden med andre verdier for endringen av posisjon, altså ikke <code>np.array([1, 0])</code>.
</p>

</div>

<div class="task" id="orgf6be9c2">
<p>
Klarer du å bruke <code>BREDDE</code> og å snu posisjonsendringen dersom partikkelen er på vei ut av skjermen?
</p>

</div>
</div>
</div>

<div id="outline-container-org1895383" class="outline-3">
<h3 id="org1895383">Fart</h3>
<div class="outline-text-3" id="text-org1895383">
<p>
Vi skal nå gi partiklene våre en ny egenskap, <code>"fart"</code>. I samme sleng lager vi også en funksjon som skal hjelpe oss på opprette nye partikler.
</p>

<p>
Først, farten kommer til å være en ny vektor, som vi så skal skalere med en tidsendring, <code>dt</code> eller \(\Delta t\).
</p>


<div id="orgca153c5" class="figure">
<p><object type="image/svg+xml" data="figurer/simulering2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 15 </span>Farten skalert med \(\Delta t\)</p>
</div>

<p>
For enklere å kunne lage flere partikler, lager vi så en funksjon <code>lag_partikkel</code>, vi ønsker at den skal oppføre seg omtrent som vist under. Altså, den skal ta inn to vektorer (posisjon og fart), en farge (en samling med r-, g- og b-verdier), et et tall (radius). Funksjonen skal returnere <i>dictionarien</i> som representerer partikkelen vår i programmet.
</p>


<div id="org5cfc639" class="figure">
<p><object type="image/svg+xml" data="figurer/simulering3.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 16 </span>En funksjon for å lage partikler</p>
</div>

<p>
Dersom vi da skriver <code>pt = lag_partikkel(np.array(50, 50), np.array(10, -10), (140, 140, 220), 15)</code> skal vi altså få en partikkel <code>pt</code> med posisjon \((50, 50)\), fart \((10, -10)\), farge \((140, 140, 220)\) og radius 15. Det vil forhåpentligvis se ut omtrent som i figuren under.
</p>


<div id="orgc819ddd" class="figure">
<p><object type="image/svg+xml" data="figurer/simulering4.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 17 </span>En partikkel fra spesifikasjonen over</p>
</div>

<div class="task" id="org416a92d">
<p>
Forsøk å skrive en funksjon som oppfyller spesifikasjonen over.
</p>

</div>

<div class="task" id="orga06bc53">
<p>
Undersøk hva som skjer om du oppdaterer denne nye partikkelens posisjon med farten, ikke <code>np.array([1, 0])</code>, som vi gjorde tidligere.
</p>

<p>
Hva ser du?
</p>

<p>
Om du ikke har fått laget <code>lag_partikkel</code> ennå, skriv inn partikkelen som vi har gjort tidligere.
</p>

</div>

<p>
Vi ser nå at partikkelen fyker ut av skjermen før vi rekker å gjøre noe. Dette er grunnet det at farten er så stor at vi nærmest ikke rekker å se partikkelen.
</p>

<p>
For å bedre på dette, kan vi tenke på hva slags enheter vi ønsker at skjermen, posisjonen og farten skal representere. Dette avhenger av hva vi ønsker å simulere, og hvor raskt vi ønsker at simuleringen skal gå på skjermen.
</p>

<p>
La oss sette inn en «hardkodet» tidsendring, \(\Delta t\), som vi gjør liten nok til at hvert skritt framover i simuleringa vår ikke er større enn at vi får en fin animasjon på skjermen.
</p>

<div class="task" id="org9c7aec5">
<p>
Ta utgangspunkt i koden under, og endre <code>dt</code> til du er fornøyd med hvordan det ser ut.
</p>

</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> pygame
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np

<span class="org-variable-name">BREDDE</span> = 800
<span class="org-variable-name">H&#216;YDE</span> = 600
<span class="org-variable-name">BAKGRUNNSFARGE</span> = (0, 0, 0)

pygame.init()
<span class="org-variable-name">klokke</span> = pygame.time.Clock()
<span class="org-variable-name">FLATE</span> = pygame.display.set_mode((BREDDE, H&#216;YDE))

<span class="org-keyword">def</span> <span class="org-function-name">lag_partikkel</span>(p0, v0, farge, radius):
    <span class="org-keyword">return</span> {<span class="org-string">"posisjon"</span>: p0,
            <span class="org-string">"fart"</span>: v0,
            <span class="org-string">"farge"</span>: farge,
            <span class="org-string">"radius"</span>: radius}

<span class="org-keyword">def</span> <span class="org-function-name">tegn_partikkel</span>(partikkel):
    pygame.draw.circle(FLATE, partikkel[<span class="org-string">"farge"</span>], 
                       partikkel[<span class="org-string">"posisjon"</span>], partikkel[<span class="org-string">"radius"</span>])

<span class="org-variable-name">pt</span> = lag_partikkel(np.array([50, 50]), np.array([10, -10]), (140, 140, 220), 15)

<span class="org-variable-name">dt</span> = 0.01
<span class="org-variable-name">kjoerer</span> = <span class="org-constant">True</span>
<span class="org-keyword">while</span> kjoerer:
    <span class="org-keyword">for</span> event <span class="org-keyword">in</span> pygame.event.get():
        <span class="org-keyword">if</span> event.<span class="org-builtin">type</span> == pygame.QUIT:
            <span class="org-variable-name">kjoerer</span> = <span class="org-constant">False</span>

    <span class="org-variable-name">pt</span>[<span class="org-string">"posisjon"</span>] = pt[<span class="org-string">"posisjon"</span>] + dt * pt[<span class="org-string">"fart"</span>]
    FLATE.fill(BAKGRUNNSFARGE)
    tegn_partikkel(pt)    <span class="org-comment-delimiter"># </span><span class="org-comment">&lt;- Obs!</span>
    pygame.display.flip()
    klokke.tick(60)

<span class="org-keyword">print</span>(<span class="org-string">"Simuleringen er ferdig."</span>)
pygame.<span class="org-constant">quit</span>()
</pre>
</div>

<p>
Med utgangspunktet over, får vi noe omtrent som figuren under.
</p>


<div id="org0753c7c" class="figure">
<p><img src="figurer/simulering_anim2.gif" alt="simulering_anim2.gif" />
</p>
<p><span class="figure-number">Illustrasjon 18 </span>En treig partikkel</p>
</div>

<p>
Merk, linja med <code># &lt;- Obs!</code> bruker en <code>tegn_partikkel</code>-funksjon som er definert lengre opp. Dette er gjort for å gjøre det tydeligst mulig hva det er som skjer på hver linje. På denne linja skjer det én ting, vi tegner en partikkel, det er ikke så viktig for oss akkurat <i>hvordan</i> vi gjør det.
</p>
</div>
</div>

<div id="outline-container-org9c6ca10" class="outline-3">
<h3 id="org9c6ca10">En forbedret tegning</h3>
<div class="outline-text-3" id="text-org9c6ca10">
<p>
Akkurat nå ser partiklene våre litt grovkornede ut. Dette kommer av hvordan pygames <code>draw.circle</code>-funksjon fungerer. Vi kan tegne penere partikler ved å bruke undermodulen <code>pygame.gfxdraw</code>. Under <code>import pygame</code> kan du skrive <code>import pygame.gfxdraw</code>, så skal vi nå endre <code>tegn_partikkel</code>-funksjonen vår.
</p>

<p>
For å få en penere sirkel, skal vi først tege et glatt omriss, så en fylt sirkel på innsiden. Dette finnes det to funksjoner for i <code>pygame.gfxdraw</code>, <code>aacircle</code> ("aa" står får <i>anti-aliased</i>, som betyr at hakkene er glattet ut) og <code>filled_circle</code>.
</p>

<p>
Endre så <code>tegn_partikkel</code>-funksjonen ved å legge til disse to funksjonene, som vist under.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">tegn_partikkel</span>(partikkel):
    <span class="org-variable-name">posisjonsvektor</span> = partikkel[<span class="org-string">"posisjon"</span>]
    <span class="org-variable-name">posisjon_x</span> = posisjonsvektor[0]
    <span class="org-variable-name">posisjon_y</span> = posisjonsvektor[1]
    <span class="org-variable-name">posisjon_x</span> = <span class="org-builtin">int</span>(posisjon_x)
    <span class="org-variable-name">posisjon_y</span> = <span class="org-builtin">int</span>(posisjon_y)
    <span class="org-variable-name">radius</span> = partikkel[<span class="org-string">"radius"</span>]
    <span class="org-variable-name">farge</span> = partikkel[<span class="org-string">"farge"</span>]
    pygame.gfxdraw.aacircle(FLATE, posisjon_x, posisjon_y,
                            radius, farge)
    pygame.gfxdraw.filled_circle(FLATE, posisjon_x, posisjon_y,
                                 radius, farge)
</pre>
</div>

<p>
Dette gir oss en partikkel med litt mindre ru overflate.
</p>


<div id="org8728bef" class="figure">
<p><img src="figurer/simulering_anim3.gif" alt="simulering_anim3.gif" />
</p>
</div>

<p>
Legg merke til at <code>gfxdraw.aacircle</code> og <code>filled_circle</code> brukes på en litt annen måte en <code>draw.circle</code>, ved at de tar inn heltallige \(x\)- og \(y\)-posisjoner. Den første delen av koden i funksjonen over kan du gjerne pynte en del på, for eksempel ved å hente ut \(x\)- og \(y\)-verdier samtidig som du bruker <code>int</code> for å gjøre dem til heltall.
</p>

<div class="task" id="org509a071">
<p>
Forsøk å gi partikkelen din en tilfeldig posisjon og fart ved å bruke <code>random.randint</code>.
</p>

</div>

<p>
Vi kommer ikke til å endre mer på <code>tegn_partikkel</code> nå. Om du er fornøyd med den forrige utgaven (hvor vi brukte <code>draw.circle</code>), er det helt i orden heller å beholde den.
</p>
</div>
</div>

<div id="outline-container-orgbf5ad9d" class="outline-3">
<h3 id="orgbf5ad9d">Partikkel og partikler</h3>
<div class="outline-text-3" id="text-orgbf5ad9d">
<p>
Nå lager vi bare én partikkel, med linja <code>pt = lag_partikkel...</code>. Vi ønsker oss en kasse med mange partikler i. Her må vi igjen tenke på hvordan vi skal representere dette i programmet vårt. Det virker uhensiktsmessig å skulle skrive det linje for linje.
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">pt1</span> = lag_partikkel...
<span class="org-variable-name">pt2</span> = lag_partikkel...
...
<span class="org-variable-name">ptn</span> = lag_partikkel...
</pre>
</div>

<p>
Det virker mer hensiktsmessig å samle partiklene, på tilsvarende måte vi samlet komponentene for en vektor. Dette er lister egnet til. Om vi ønsker å lage en liste, <code>partikler</code> med ti tilfeldige partikler i, kan vi gjøre det for eksempel som følger:
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">partikler</span> = []         <span class="org-comment-delimiter"># </span><span class="org-comment">en tom partikkelliste</span>
<span class="org-keyword">for</span> _ <span class="org-keyword">in</span> <span class="org-builtin">range</span>(10):    <span class="org-comment-delimiter"># </span><span class="org-comment">f&#248;lgende kode gjentas ti ganger</span>
    <span class="org-variable-name">xpos</span> = randint(0, BREDDE)   <span class="org-comment-delimiter"># </span><span class="org-comment">tilfeldig x-pos innenfor skjermen</span>
    <span class="org-variable-name">ypos</span> = randint(0, H&#216;YDE)    <span class="org-comment-delimiter"># </span><span class="org-comment">tilfeldig y-pos innenfor skjermen</span>
    <span class="org-variable-name">posisjon</span> = np.array([xpos, ypos])  <span class="org-comment-delimiter"># </span><span class="org-comment">posisjonsvektor</span>
    <span class="org-variable-name">xfart</span> = randint(0, 10)      <span class="org-comment-delimiter"># </span><span class="org-comment">startfart i x-retning</span>
    <span class="org-variable-name">yfart</span> = radnint(0, 10)      <span class="org-comment-delimiter"># </span><span class="org-comment">startfart i y-retning</span>
    <span class="org-variable-name">fart</span> = np.array([xfart, yfart])
    <span class="org-variable-name">radius</span> = randint(10, 20)    <span class="org-comment-delimiter"># </span><span class="org-comment">tilfeldig radius</span>
    <span class="org-variable-name">farge</span> = (140, 140, 220)     <span class="org-comment-delimiter"># </span><span class="org-comment">denne kan ogs&#229; settes tilfeldig</span>
    <span class="org-variable-name">pt</span> = lag_partikkel(posisjon, fart, farge, radius)
    partikler.append(pt)        <span class="org-comment-delimiter"># </span><span class="org-comment">legger den nye partikkelen i lista</span>
</pre>
</div>

<p>
Etter denne koden har kjørt, er <code>partikler</code> en liste med ti partikler, alle tilfeldig bestemt.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> pygame
<span class="org-keyword">import</span> pygame.gfxdraw

<span class="org-keyword">import</span> random <span class="org-keyword">as</span> rnd
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np

<span class="org-variable-name">BREDDE</span> = 800
<span class="org-variable-name">H&#216;YDE</span> = 600
<span class="org-variable-name">BAKGRUNNSFARGE</span> = (0, 0, 0)
<span class="org-variable-name">dt</span> = 0.1

pygame.init()
<span class="org-variable-name">klokke</span> = pygame.time.Clock()
<span class="org-variable-name">FLATE</span> = pygame.display.set_mode((BREDDE, H&#216;YDE))

<span class="org-keyword">def</span> <span class="org-function-name">lag_partikkel</span>(p0, v0, farge, radius):
    <span class="org-keyword">return</span> {<span class="org-string">"posisjon"</span>: p0,
            <span class="org-string">"fart"</span>: v0,
            <span class="org-string">"farge"</span>: farge,
            <span class="org-string">"radius"</span>: radius}

<span class="org-keyword">def</span> <span class="org-function-name">tegn_partikkel</span>(partikkel):
    <span class="org-variable-name">posisjonsvektor</span> = partikkel[<span class="org-string">"posisjon"</span>]
    <span class="org-variable-name">posisjon_x</span> = posisjonsvektor[0]
    <span class="org-variable-name">posisjon_y</span> = posisjonsvektor[1]
    <span class="org-variable-name">posisjon_x</span> = <span class="org-builtin">int</span>(posisjon_x)
    <span class="org-variable-name">posisjon_y</span> = <span class="org-builtin">int</span>(posisjon_y)
    <span class="org-variable-name">radius</span> = partikkel[<span class="org-string">"radius"</span>]
    <span class="org-variable-name">farge</span> = partikkel[<span class="org-string">"farge"</span>]
    pygame.gfxdraw.aacircle(FLATE, posisjon_x, posisjon_y,
                            radius, farge)
    pygame.gfxdraw.filled_circle(FLATE, posisjon_x, posisjon_y,
                                 radius, farge)

<span class="org-variable-name">partikler</span> = []
<span class="org-keyword">for</span> _ <span class="org-keyword">in</span> <span class="org-builtin">range</span>(10):
    <span class="org-variable-name">xpos</span> = rnd.randint(0, BREDDE)
    <span class="org-variable-name">ypos</span> = rnd.randint(0, H&#216;YDE)
    <span class="org-variable-name">posisjon</span> = np.array([xpos, ypos])
    <span class="org-variable-name">xfart</span> = rnd.randint(0, 10)
    <span class="org-variable-name">yfart</span> = rnd.randint(0, 10)
    <span class="org-variable-name">fart</span> = np.array([xfart, yfart])
    <span class="org-variable-name">radius</span> = rnd.randint(10, 20)
    <span class="org-variable-name">farge</span> = (140, 140, 220)
    <span class="org-variable-name">pt</span> = lag_partikkel(posisjon, fart, farge, radius)
    partikler.append(pt)        

<span class="org-variable-name">kjoerer</span> = <span class="org-constant">True</span>
<span class="org-keyword">while</span> kjoerer:
    <span class="org-keyword">for</span> event <span class="org-keyword">in</span> pygame.event.get():
        <span class="org-keyword">if</span> event.<span class="org-builtin">type</span> == pygame.QUIT:
            <span class="org-variable-name">kjoerer</span> = <span class="org-constant">False</span>

    <span class="org-keyword">for</span> pt <span class="org-keyword">in</span> partikler:
        <span class="org-variable-name">pt</span>[<span class="org-string">"posisjon"</span>] = pt[<span class="org-string">"posisjon"</span>] + dt * pt[<span class="org-string">"fart"</span>]

    FLATE.fill(BAKGRUNNSFARGE)

    <span class="org-keyword">for</span> pt <span class="org-keyword">in</span> partikler:
        tegn_partikkel(pt)

    pygame.display.flip()
    klokke.tick(60)

<span class="org-keyword">print</span>(<span class="org-string">"Simuleringen er ferdig."</span>)
pygame.<span class="org-constant">quit</span>()
</pre>
</div>

<p>
Merk deg at vi nå løper gjennom en liste med partikler både når vi vil tegne partiklene, og når vi vil oppdatere partiklenes posisjon.
</p>

<div class="task" id="org519d27d">
<p>
Fiks programmet slik at ikke alle partiklene beveger seg nedover mot høyre.
</p>

</div>

<div class="task" id="org4a39968">
<p>
Hvis vi ønsker oss at \(y\)-aksen skal være positiv <i>oppover</i>, istedenfor <i>nedover</i> som det er nå, kan vi, om vi ønsker, fikse det i <code>tegn_partikkel</code>-funksjonen vår.
</p>

<p>
Har du et forslag til hvordan vi kan gjøre det?
</p>

</div>
</div>
</div>
</div>
</div>
</body>
</html>
