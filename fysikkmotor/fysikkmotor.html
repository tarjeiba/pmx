<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="nb" xml:lang="nb">
<head>
<!-- 2020-11-18 Wed 14:23 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fysikkmotor</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Tarjei Bærland" />
<link rel="stylesheet" type="text/css" href="./style.css" />
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Fysikkmotor</h1>
<p>
Gjennom dette oppgavearket skal vi lage en fysikkmotor ved å bruke Python og Pygame. Vi kommer omtrentlig til å ha en gjennomgang som følger
</p>

<dl class="org-dl">
<dt><a href="#vektorer">Vektorer</a></dt><dd>Hvordan kan vi representerere vektorer i et python-program?</dd>
<dt><a href="fysikkmotor.html#ID-0b6d9763-24d2-4b31-9abc-3bf52bb81e94">Partikler</a></dt><dd>Kan vi samle flere egenskaper enn bare tall til i én verdi?</dd>
<dt><a href="fysikkmotor.html#ID-9a55573e-44bf-4921-acf1-c5d66ede7d5d">Simulering</a></dt><dd>Trinnvis framover i Pygame</dd>
<dt><a href="fysikkmotor.html#ID-050ff933-d1a8-4d9b-8be9-ef5dc351ef1b">Kollisjoner</a></dt><dd>Kan partiklene våre kollidere med hverandre?</dd>
<dt><a href="fysikkmotor.html#ID-f55222e8-5b25-4fce-aad3-f66217831d2c">Bugfikser</a></dt><dd>Utbedringer kommer til å være nødvendig.</dd>
<dt><a href="fysikkmotor.html#ID-fd134f56-3103-448a-ae32-4e7679b7e50e">Utforsking</a></dt><dd>Hvilke andre modeller kan vi bruke partiklene våre til?</dd>
</dl>

<div id="outline-container-vektorer" class="outline-2">
<h2 id="vektorer">Vektorer</h2>
<div class="outline-text-2" id="text-vektorer">
<p>

</p>
</div>

<div id="outline-container-org17253b1" class="outline-3">
<h3 id="org17253b1">Introduksjon</h3>
<div class="outline-text-3" id="text-org17253b1">
<p>
Fra matematikken kjenner vi en vektor som noe med størrelse og retning. Ofte illustrerer vi dette med en pil. Under vises vektoren \(\vec{v}\) tegnet som en pil i planet.
</p>


<div id="orgf07f11f" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 1 </span>En vektor illustrert som en pil</p>
</div>

<p>
En vektor avhenger ikke av hvor vi tegner den, kun av dens størrelse og retning, altså vil disse to vektorene være den samme, til tross for at de er «ved siden av hverandre».
</p>


<div id="orga127772" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 2 </span>To like vektorer, altså to av den samme vektoren</p>
</div>

<p>
Dette er altså tilsvarende at tallet 3 er tallet 3, uavhengig av hvor vi møter det.
</p>

<p>
Før vi kan representere en vektor i et dataprogram, må vi bestemme oss for hvordan vi ønsker å <i>representere</i> vektoren. Vi kan for eksempel se for oss vektoren \(\vec{v}\) som en pil, hvor lengden til \(\vec{v}\), den såkalte <i>absoluttverdien</i>, er \(|\vec{v}| = 3\) og vinkelen mellom \(\vec{v}\) og en horisontalakse er \(\theta = 30^{\circ}\).
</p>


<div id="orgb55faf6" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor3.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 3 </span>En vektor, dens størrelse og dens retning</p>
</div>

<p>
Om vi så ønsker å representere dette i et python-program, kan vi for eksempel skrive
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">absoluttverdi</span> = 3
<span class="org-variable-name">vinkel</span> = 30
</pre>
</div>

<p>
Dette byr på en serie problemer, blant annet at vi nå har to variabler for å holde styr på det som strengt tatt bare er én matematisk størrelse, vektoren \(\vec{v}\).
</p>

<div class="task" id="orgc928d72">
<p>
Om du allerede kjenner til vektorer, stopp opp her og tenk på hvordan du ville representert dem i kode.
</p>

</div>
</div>
</div>

<div id="outline-container-org0f09147" class="outline-3">
<h3 id="org0f09147">Addisjon</h3>
<div class="outline-text-3" id="text-org0f09147">
<p>
Vi er vant til at \(\text{tall} + \text{tall} = \text{tall}\) og at \(\text{tall} \cdot \text{tall} = \text{tall}\).
</p>

<p>
For vektorer er addisjon som forventet, \(\text{vektor} + \text{vektor} = \text{vektor}\). For å visualisere en vektorsumm, kan vi sette de to vektorleddene etter hverandre. Under vises \(\vec{u}\) og \(\vec{v}\).
</p>


<div id="org14cdb45" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor4.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 4 </span>To vektorer</p>
</div>

<p>
For å legge disse sammen visuelt, kan vi sette de etter hverandre, slik at \(\vec{v}\) starter der \(\vec{u}\) slutter. Summen \(\vec{u} + \vec{v}\) er da en <i>ny vektor</i> som starter der \(\vec{u}\) starter og slutter der \(\vec{v}\) slutter.
</p>


<div id="org197e1de" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor5.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 5 </span>Vektorsum</p>
</div>

<p>
Essensen her er at summen av to vektorer er en ny vektor.
</p>

<div class="task" id="orgdb8950b">
<p>
Om vi har to vektorer representert som to lengder og to vinkler, à la det beskrevet tidligere. Hvordan kan vi gå fram for å finne vektorsummen av disse?
</p>

</div>
</div>
</div>

<div id="outline-container-orgd8b0234" class="outline-3">
<h3 id="orgd8b0234">Dekomponering</h3>
<div class="outline-text-3" id="text-orgd8b0234">
<p>
Vi <i>dekomponerer</i> en vektor ved å skrive den som en sum av vektorer, vi finner dens <i>komponenter</i>. Det vanligste er å la hver av disse komponentene ligge langs en koordinatakse. Under har vi dekomponert \(\vec{v}\) til en vektor i \(x\)-retning, \(\vec{v}_x\) og en vektor i \(y\)-retning, \(\vec{v}_y\).
</p>


<div id="org133bd9f" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor6.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 6 </span>Dekomponering</p>
</div>

<p>
Merk at de to vektorene \(\vec{v}_x\) og \(\vec{v}_y\) er de <i>eneste</i> to vektorene i \(x\)- og \(y\)-retning hvor summen gir \(\vec{v}\), altså er \(\vec{v}\) <i>entydig</i> bestemt av de to vektorene. Om vi da skriver \(|\vec{v}_x| = v_x\) og \(|\vec{v}_y| = v_y\), kan vi samle det hele til \[\vec{v} = \left[v_x, v_y\right].\]
</p>

<p>
Vi sier at vi nå har skrevet \(\vec{v}\) på <i>koordinatform</i>. For eksempel, dersom vi har \(\vec{v}\) som definert over, vil vi få
</p>

\begin{aligned}
\vec{v} &= \left[|\vec{v}_x|, |\vec{v}_y|\right] \\
        &= \left[|\vec{v}| \cos 30^{\circ}, |\vec{v}| \sin 30^{\circ} \right] \\
        &= \left[3\cdot \tfrac{\sqrt{3}}{2}, 3\cdot\tfrac{1}{2} \right] \\
        &= \left[\tfrac{3\sqrt{3}}{2}, \tfrac{3}{2} \right].
\end{aligned}

<div class="task" id="org7edd69c">
<p>
Hvordan kan vi representerer vektorer på koordinatform i et program?
</p>

</div>
</div>
</div>

<div id="outline-container-org9ffbb87" class="outline-3">
<h3 id="org9ffbb87">Omforming</h3>
<div class="outline-text-3" id="text-org9ffbb87">
<p>
Vektorer på koordinatform har en annen fin egenskap, summen av to vektorer er den komponentvise summen av leddene. Altså er
</p>

\begin{aligned}
\vec{u} + \vec{v} &= \left[u_x, u_y\right] + \left[v_x, v_y\right] \\
                  &= \left[u_x + v_x, u_y + v_y\right].
\end{aligned}

<p>
Merk at også når vi ønsker å representere vektorer på koordinatform med tall, trenger vi to tall om vektoren er i to dimensjoner (i planet). Det ser ut som at uansett hvordan vi representerer vektorer med tall, trenger vi like mange tall som vi har dimensjoner for vektoren.
</p>

<p>
Naivt kunne vi tenkt at vi skulle representert vektoren på en form à la
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">x_koordinat</span> = 2.598  <span class="org-comment-delimiter"># </span><span class="org-comment">3 * cos(30 grader)</span>
<span class="org-variable-name">y_koordinat</span> = 1.500  <span class="org-comment-delimiter"># </span><span class="org-comment">3 * sin(30 grader)</span>
</pre>
</div>

<div class="task" id="orgb491396">
<p>
Lag et program som tar inn en vektor med lengde og vinkel, og returnerer en vektor på koordinatform. Du kan for eksempel lage det som en funksjon på formen
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">polar_til_koordinat</span>(lengde, vinkel):
    <span class="org-comment-delimiter"># </span><span class="org-comment">dine utregninger</span>
    <span class="org-keyword">return</span> [x_koordinat, y_koordinat]
</pre>
</div>

<p>
Legg merke til her at vi har valgt å representere vektoren på koordinatform som en liste. Dette er fordi vi ikke kan ha en funksjon i python som returerner to uavhengige verdier uten at disse pakkes sammen på et vis.
</p>

</div>

<div class="task" id="org5ad0a33">
<p>
Skriv et program som regner ut summen av de to vektorene under. Kall svaret ditt <code>w</code>.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">u</span> = [1, 3]
<span class="org-variable-name">v</span> = [4, 5]
</pre>
</div>

</div>

<div class="task" id="org87c5309">
<p>
Skriv en funksjon som tar inn en vektor på koordinatform, da som en liste av to verdier, og returnerer en liste med vektorens <code>lengde</code> og <code>vinkel</code>. Du kan kalle funksjonen <code>koordinat_til_polar</code>.
</p>

</div>
</div>
</div>

<div id="outline-container-orgbaf5c5a" class="outline-3">
<h3 id="orgbaf5c5a">Representasjonsform</h3>
<div class="outline-text-3" id="text-orgbaf5c5a">
<p>
Vi har nå sett at det matematisk finnes ulike ekvivalente måter å representere en vektor på, som et sett av lengde og vinkel, som \(x\)- og \(y\)-koordinater, og vi kunne tenkt oss mange flere (de fleste av dem uhensiktsmessige i de fleste tilfeller, som et sett av lengde og en \(x\)-koordinat).
</p>

<p>
Vi begynner også å ane konturene av at det er uendelig mange måter å representere vektorer i dataprogrammer, som enkeltvariabler, som en liste, og som andre «sammensatte datatyper».
</p>

<p>
Under oppgaven med vektoraddisjon, så vi dog at listerepresentasjonen, om enn den samler vektoren til ett format, ikke er hensiktsmessig for addisjon. Et bedre alternativ da er å bruke et <code>numpy-array</code>. Vi får dette ved å skrive for eksempel
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np

<span class="org-variable-name">u</span> = np.array([2.598, 1.500])  <span class="org-comment-delimiter"># </span><span class="org-comment">3 * sin(30 grader)</span>
</pre>
</div>

<div class="task" id="orga4e7799">
<p>
Forsøk å se hvordan addisjon av vektorer fungerer nå. Start med en vektor <code>u</code> og en vektor <code>v</code>, hver representert som et numpy-array, og test ut addisjon ved å bruke et vanlig <code>+</code>-tegn.
</p>

<p>
Hva observerer du?
</p>

<p>
Test det samme om de to vektorene hadde vært vanlige lister.
</p>

<p>
Kommenter.
</p>

</div>
</div>
</div>

<div id="outline-container-org6f82046" class="outline-3">
<h3 id="org6f82046">Skalarproduktet</h3>
<div class="outline-text-3" id="text-org6f82046">
<p>
Vi har sett at addisjon fungerer som vi forventer mellom vektorer, en sum av to vektorer er en ny vektor. Hva med multiplikasjon?
</p>

<p>
Vel. For vekterorer operer vi gjerne med <i>to</i> typer multiplikasjon, et såkalt <i>skalarprodukt</i> og et <i>vektorprodukt</i>. Vi noterer det som \(\vec{u}\cdot\vec{v}\) for skalarproduktet og \(\vec{u}\times\vec{v}\). Det overraskende her er at <i>skalarproduktet</i> tar inn to vektorer og gir ut et tall (en skalar), mens vektorproduktet tar inn to vektorer og gir ut en vektor.
</p>

<p>
Inntil videre er det kun skalarproduktet vi skal ta hensyn til.
</p>

<p>
På samme måte som at det finnes ulike måter å tenke på vektorer, finnes det ulike måter å tenke på skalarproduktet. En av disse er å si at « \(\vec{u}\cdot\vec{v}\) er lengden av \(\vec{u}\) ganget med lengden av den delen til \(\vec{v}\) som ligger langs \(\vec{u}\)».
</p>

<p>
Dette er muligens ikke helt opplagt, for da virker det for eksempel som at \(\vec{u}\cdot\vec{v}\) er noe annet enn \(\vec{v}\cdot\vec{y}\), men det skal være det samme.
</p>

<p>
Vi kan vise denne vektormultiplikasjonen som under.
</p>


<div id="orgad24678" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor7.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 7 </span>\(\vec{v}\) <i>projisert</i> på \(\vec{u}\)</p>
</div>

<div class="task" id="orgc3f9fb6">
<p>
Lag et program som tar inn to vektorer, \(u\) og \(v\) (du kan bruke de samme som i eksempelet over). Regn ut \(\vec{u}\cdot\vec{v}\) ved å bruke at \[\vec{u}\cdot\vec{v} = |\vec{u}||\vec{v}|\cos \theta,\] hvor \(\theta\) er vinkelen mellom \(\vec{u}\) og \(\vec{v}\).
</p>

</div>

<p>
Om vi har vektorene representert på koordinatform, er det en enkel sak å regne ut skalarproduktet. Vi kan da bruke at 
</p>

\begin{aligned}
\vec{u}\cdot\vec{v} &= \left[u_x, u_y\right]\cdot\left[v_x, v_y\right] \\
                    &= u_x v_x + u_y v_y
\end{aligned}

<div class="task" id="org29be937">
<p>
Lag et program som tar inn to vektorer på koordinatform i lister. Regn ut vektorenes skalarprodukt ved å bruke definisjonen over.
</p>

<p>
Du kan for eksempel ta utgangspunkt i følgende:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">u</span> = [-5, 8]
<span class="org-variable-name">v</span> = [-3, 1]
</pre>
</div>

</div>

<p>
Skalarproduktet oppstår i mange områder av matematikken. I <code>numpy</code> har vi det innebygd som <code>dot</code>-funksjonen. For eksempel vil <code>np.dot(a, b)</code> regne ut skalarproduktet (eller «prikkproduktet» eller «dotproduktet») til de to vektorene <code>a</code> og <code>b</code>.
</p>

<div class="task" id="org63ab528">
<p>
Lag et program som tar inn to vektorer på koordinatform i numpy-arrayer. Regn ut vektorenes skalarprodukt ved å bruke <code>np.dot</code>.
</p>

<p>
Du kan for eksempel ta utgangspunkt i følgende:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">u</span> = np.array([-5, 8])
<span class="org-variable-name">v</span> = np.array([-3, 1])
</pre>
</div>

</div>
</div>
</div>

<div id="outline-container-org5114e03" class="outline-3">
<h3 id="org5114e03">Skalering eller skalarmultiplikasjon</h3>
<div class="outline-text-3" id="text-org5114e03">
<p>
Ordet «skalar» brukes ofte om tall i vektorsammenheng. Bakgrunnen for dette navnet er nettopp at et tall multiplisert med en vektor gir en <i>skalert</i> vektor. Vi kan bruke ordene «skalar» og «tall» om hverandre.
</p>

<p>
En vektor \(\vec{v}\) skalert med et tall \(t\) er en ny vektor med samme retning som \(\vec{v}\) og lengde \(t|\vec{v}|\).
</p>


<div id="org7595237" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor8.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 8 </span>Skalerte vektorer</p>
</div>

<p>
Her er \(0 < a < 1\), \(b > 1\) og \(c < 0\). Vi ser altså at en negativ skalering av en vektor gir en vektor med motsatt retning. For eksemplene i figuren over, er \(|b| = |c|\).
</p>

<div class="task" id="org8529005">
<p>
Undersøk om <code>np.dot(t, v)</code> fungerer som forventet dersom <code>t</code> er et tall og <code>v</code> er en vektor i form av et numpy-array.
</p>

</div>
</div>
</div>
</div>
</div>
</body>
</html>
