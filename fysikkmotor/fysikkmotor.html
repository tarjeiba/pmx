<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="nb" xml:lang="nb">
<head>
<!-- 2020-11-25 Wed 15:05 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fysikkmotor</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Tarjei Bærland" />
<link rel="stylesheet" type="text/css" href="./style.css" />
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Fysikkmotor</h1>
<p>
Gjennom dette oppgavearket skal vi lage en fysikkmotor ved å bruke Python og Pygame. Vi kommer omtrentlig til å ha en gjennomgang som følger
</p>
<dl class="org-dl">
<dt><a href="#vektorer">Vektorer</a></dt><dd>Hvordan kan vi representerere vektorer i et python-program?</dd>
<dt><a href="#partikler">Partikler</a></dt><dd>Kan vi samle flere egenskaper enn bare tall til i én verdi?</dd>
<dt><a href="fysikkmotor.html#ID-9a55573e-44bf-4921-acf1-c5d66ede7d5d">Simulering</a></dt><dd>Trinnvis framover i Pygame</dd>
<dt><a href="fysikkmotor.html#ID-050ff933-d1a8-4d9b-8be9-ef5dc351ef1b">Kollisjoner</a></dt><dd>Kan partiklene våre kollidere med hverandre?</dd>
<dt><a href="fysikkmotor.html#ID-f55222e8-5b25-4fce-aad3-f66217831d2c">Bugfikser</a></dt><dd>Utbedringer kommer til å være nødvendig.</dd>
<dt><a href="fysikkmotor.html#ID-fd134f56-3103-448a-ae32-4e7679b7e50e">Utforsking</a></dt><dd>Hvilke andre modeller kan vi bruke partiklene våre til?</dd>
</dl>

<p>
Motoren kommer til å ta form av en virtuell kasse som det spretter partikler rundt inni. Denne kan vi forhåpentligvis bruke til å gjennomføre ulike modelleringsforsøk.
</p>

<div id="outline-container-vektorer" class="outline-2">
<h2 id="vektorer">Vektorer</h2>
<div class="outline-text-2" id="text-vektorer">
<p>

</p>
</div>

<div id="outline-container-org3931afc" class="outline-3">
<h3 id="org3931afc">Introduksjon</h3>
<div class="outline-text-3" id="text-org3931afc">
<p>
Fra matematikken kjenner vi en vektor som noe med størrelse og retning. Ofte illustrerer vi dette med en pil. Under vises vektoren \(\vec{v}\) tegnet som en pil i planet.
</p>


<div id="org317f9b0" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 1 </span>En vektor illustrert som en pil</p>
</div>

<p>
En vektor avhenger ikke av hvor vi tegner den, kun av dens størrelse og retning, altså vil disse to vektorene være den samme, til tross for at de er «ved siden av hverandre».
</p>


<div id="org51ea688" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 2 </span>To like vektorer, altså to av den samme vektoren</p>
</div>

<p>
Dette er altså tilsvarende at tallet 3 er tallet 3, uavhengig av hvor vi møter det.
</p>

<p>
Før vi kan representere en vektor i et dataprogram, må vi bestemme oss for hvordan vi ønsker å <i>representere</i> vektoren. Vi kan for eksempel se for oss vektoren \(\vec{v}\) som en pil, hvor lengden til \(\vec{v}\), den såkalte <i>absoluttverdien</i>, er \(|\vec{v}| = 3\) og vinkelen mellom \(\vec{v}\) og en horisontalakse er \(\theta = 30^{\circ}\).
</p>


<div id="orgb0dd7d3" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor3.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 3 </span>En vektor, dens størrelse og dens retning</p>
</div>

<p>
Om vi så ønsker å representere dette i et python-program, kan vi for eksempel skrive
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">absoluttverdi</span> = 3
<span class="org-variable-name">vinkel</span> = 30
</pre>
</div>

<p>
Dette byr på en serie problemer, blant annet at vi nå har to variabler for å holde styr på det som strengt tatt bare er én matematisk størrelse, vektoren \(\vec{v}\).
</p>

<div class="task" id="org0be03e5">
<p>
Om du allerede kjenner til vektorer, stopp opp her og tenk på hvordan du ville representert dem i kode.
</p>

</div>
</div>
</div>

<div id="outline-container-orgf8611f2" class="outline-3">
<h3 id="orgf8611f2">Addisjon</h3>
<div class="outline-text-3" id="text-orgf8611f2">
<p>
Vi er vant til at \(\text{tall} + \text{tall} = \text{tall}\) og at \(\text{tall} \cdot \text{tall} = \text{tall}\).
</p>

<p>
For vektorer er addisjon som forventet, \(\text{vektor} + \text{vektor} = \text{vektor}\). For å visualisere en vektorsumm, kan vi sette de to vektorleddene etter hverandre. Under vises \(\vec{u}\) og \(\vec{v}\).
</p>


<div id="orgac08817" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor4.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 4 </span>To vektorer</p>
</div>

<p>
For å legge disse sammen visuelt, kan vi sette de etter hverandre, slik at \(\vec{v}\) starter der \(\vec{u}\) slutter. Summen \(\vec{u} + \vec{v}\) er da en <i>ny vektor</i> som starter der \(\vec{u}\) starter og slutter der \(\vec{v}\) slutter.
</p>


<div id="org24721d9" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor5.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 5 </span>Vektorsum</p>
</div>

<p>
Essensen her er at summen av to vektorer er en ny vektor.
</p>

<div class="task" id="orgeeed966">
<p>
Om vi har to vektorer representert som to lengder og to vinkler, à la det beskrevet tidligere. Hvordan kan vi gå fram for å finne vektorsummen av disse?
</p>

</div>
</div>
</div>

<div id="outline-container-orgabb533f" class="outline-3">
<h3 id="orgabb533f">Dekomponering</h3>
<div class="outline-text-3" id="text-orgabb533f">
<p>
Vi <i>dekomponerer</i> en vektor ved å skrive den som en sum av vektorer, vi finner dens <i>komponenter</i>. Det vanligste er å la hver av disse komponentene ligge langs en koordinatakse. Under har vi dekomponert \(\vec{v}\) til en vektor i \(x\)-retning, \(\vec{v}_x\) og en vektor i \(y\)-retning, \(\vec{v}_y\).
</p>


<div id="orgd4f27a0" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor6.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 6 </span>Dekomponering</p>
</div>

<p>
Merk at de to vektorene \(\vec{v}_x\) og \(\vec{v}_y\) er de <i>eneste</i> to vektorene i \(x\)- og \(y\)-retning hvor summen gir \(\vec{v}\), altså er \(\vec{v}\) <i>entydig</i> bestemt av de to vektorene. Om vi da skriver \(|\vec{v}_x| = v_x\) og \(|\vec{v}_y| = v_y\), kan vi samle det hele til \[\vec{v} = \left[v_x, v_y\right].\]
</p>

<p>
Vi sier at vi nå har skrevet \(\vec{v}\) på <i>koordinatform</i>. For eksempel, dersom vi har \(\vec{v}\) som definert over, vil vi få
</p>

\begin{aligned}
\vec{v} &= \left[|\vec{v}_x|, |\vec{v}_y|\right] \\
        &= \left[|\vec{v}| \cos 30^{\circ}, |\vec{v}| \sin 30^{\circ} \right] \\
        &= \left[3\cdot \tfrac{\sqrt{3}}{2}, 3\cdot\tfrac{1}{2} \right] \\
        &= \left[\tfrac{3\sqrt{3}}{2}, \tfrac{3}{2} \right].
\end{aligned}

<div class="task" id="orgcd48a01">
<p>
Hvordan kan vi representerer vektorer på koordinatform i et program?
</p>

</div>
</div>
</div>

<div id="outline-container-org0d52735" class="outline-3">
<h3 id="org0d52735">Omforming</h3>
<div class="outline-text-3" id="text-org0d52735">
<p>
Vektorer på koordinatform har en annen fin egenskap, summen av to vektorer er den komponentvise summen av leddene. Altså er
</p>

\begin{aligned}
\vec{u} + \vec{v} &= \left[u_x, u_y\right] + \left[v_x, v_y\right] \\
                  &= \left[u_x + v_x, u_y + v_y\right].
\end{aligned}

<p>
Merk at også når vi ønsker å representere vektorer på koordinatform med tall, trenger vi to tall om vektoren er i to dimensjoner (i planet). Det ser ut som at uansett hvordan vi representerer vektorer med tall, trenger vi like mange tall som vi har dimensjoner for vektoren.
</p>

<p>
Naivt kunne vi tenkt at vi skulle representert vektoren på en form à la
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">x_koordinat</span> = 2.598  <span class="org-comment-delimiter"># </span><span class="org-comment">3 * cos(30 grader)</span>
<span class="org-variable-name">y_koordinat</span> = 1.500  <span class="org-comment-delimiter"># </span><span class="org-comment">3 * sin(30 grader)</span>
</pre>
</div>

<div class="task" id="org68aabbb">
<p>
Lag et program som tar inn en vektor med lengde og vinkel, og returnerer en vektor på koordinatform. Du kan for eksempel lage det som en funksjon på formen
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">polar_til_koordinat</span>(lengde, vinkel):
    <span class="org-comment-delimiter"># </span><span class="org-comment">dine utregninger</span>
    <span class="org-keyword">return</span> [x_koordinat, y_koordinat]
</pre>
</div>

<p>
Legg merke til her at vi har valgt å representere vektoren på koordinatform som en liste. Dette er fordi vi ikke kan ha en funksjon i python som returerner to uavhengige verdier uten at disse pakkes sammen på et vis.
</p>

</div>

<div class="task" id="orgfdbc6ea">
<p>
Skriv et program som regner ut summen av de to vektorene under. Kall svaret ditt <code>w</code>.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">u</span> = [1, 3]
<span class="org-variable-name">v</span> = [4, 5]
</pre>
</div>

</div>

<div class="task" id="orga6f40d3">
<p>
Skriv en funksjon som tar inn en vektor på koordinatform, da som en liste av to verdier, og returnerer en liste med vektorens <code>lengde</code> og <code>vinkel</code>. Du kan kalle funksjonen <code>koordinat_til_polar</code>.
</p>

</div>
</div>
</div>

<div id="outline-container-orgd86b924" class="outline-3">
<h3 id="orgd86b924">Representasjonsform</h3>
<div class="outline-text-3" id="text-orgd86b924">
<p>
Vi har nå sett at det matematisk finnes ulike ekvivalente måter å representere en vektor på, som et sett av lengde og vinkel, som \(x\)- og \(y\)-koordinater, og vi kunne tenkt oss mange flere (de fleste av dem uhensiktsmessige i de fleste tilfeller, som et sett av lengde og en \(x\)-koordinat).
</p>

<p>
Vi begynner også å ane konturene av at det er uendelig mange måter å representere vektorer i dataprogrammer, som enkeltvariabler, som en liste, og som andre «sammensatte datatyper».
</p>

<p>
Under oppgaven med vektoraddisjon, så vi dog at listerepresentasjonen, om enn den samler vektoren til ett format, ikke er hensiktsmessig for addisjon. Et bedre alternativ da er å bruke et <code>numpy-array</code>. Vi får dette ved å skrive for eksempel
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np

<span class="org-variable-name">u</span> = np.array([2.598, 1.500])  <span class="org-comment-delimiter"># </span><span class="org-comment">3 * sin(30 grader)</span>
</pre>
</div>

<div class="task" id="orgecc64b0">
<p>
Forsøk å se hvordan addisjon av vektorer fungerer nå. Start med en vektor <code>u</code> og en vektor <code>v</code>, hver representert som et numpy-array, og test ut addisjon ved å bruke et vanlig <code>+</code>-tegn.
</p>

<p>
Hva observerer du?
</p>

<p>
Test det samme om de to vektorene hadde vært lister.
</p>

<p>
Kommenter svarene dine.
</p>

</div>
</div>
</div>

<div id="outline-container-org42df196" class="outline-3">
<h3 id="org42df196">Skalarproduktet</h3>
<div class="outline-text-3" id="text-org42df196">
<p>
Vi har sett at addisjon fungerer som vi forventer mellom vektorer, en sum av to vektorer er en ny vektor. Hva med multiplikasjon?
</p>

<p>
Vel. For vektorer operer vi gjerne med <i>to</i> typer multiplikasjon, et såkalt <i>skalarprodukt</i> og et <i>vektorprodukt</i>. Vi noterer det som \(\vec{u}\cdot\vec{v}\) for skalarproduktet og \(\vec{u}\times\vec{v}\). Det overraskende her er at <i>skalarproduktet</i> tar inn to vektorer og gir ut et tall (en skalar), mens vektorproduktet tar inn to vektorer og gir ut en vektor.
</p>

<p>
Inntil videre er det kun skalarproduktet vi skal ta hensyn til.
</p>

<p>
På samme måte som at det finnes ulike måter å tenke på vektorer, finnes det ulike måter å tenke på skalarproduktet. En av disse er å si at « \(\vec{u}\cdot\vec{v}\) er lengden av \(\vec{u}\) ganget med lengden av den delen av \(\vec{v}\) som ligger langs \(\vec{u}\)».
</p>

<p>
«Den delen av \(\vec{v}\) som ligger langs \(\vec{u}\)» er illustert under. Om vi lar \(\vec{u}\) og \(\vec{v}\) starte i samme punkt, og trekker enden av \(\vec{v}\) «loddrett ned på \(\vec{u}\)» får vi delen av \(\vec{v}\) som ligger langs \(\vec{u}\) som \(\vec{v}_u\). Dette er vist under.
</p>


<div id="orgbb8ca21" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor7a.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 7 </span>\(\vec{v}_u\) er delen av \(\vec{v}\) som ligger langs \(\vec{u}\)</p>
</div>

<p>
Lengden av \(\vec{v}_u\) da skrives \(|\vec{v}|\cos\theta\), som enklere vises om vi orienterer oss slik at \(\vec{u}\) ligger langs horisontalaksen.
</p>


<div id="orgd06f68a" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor7a1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 8 </span>Lengden av \(\vec{v}_u\)</p>
</div>

<p>
Vi sier at vi har funnet <i>projeksjonen</i> av \(\vec{v}\) på \(\vec{u}\), \(\vec{v}_u\).
</p>

<p>
Kan vi med dette få en intuisjon av hva \(\vec{u}\cdot\vec{v}\) er?
</p>

<p>
Ja, \(\vec{u}\cdot\vec{v}\) er «lengden av \vec{u} ganget med lengden av \(\vec{v}_u\)». Altså har vi at \(\vec{u}\cdot\vec{v} = |\vec{u}||\vec{v}_u|\).
</p>

<div class="task" id="orge3e6865">
<p>
Lag et program som tar inn to vektorer, \(u\) og \(v\) (du kan bruke de samme som i eksempelet over). Regn ut \(\vec{u}\cdot\vec{v}\) ved å bruke at \[\vec{u}\cdot\vec{v} = |\vec{u}||\vec{v}|\cos \theta,\] hvor \(\theta\) er vinkelen mellom \(\vec{u}\) og \(\vec{v}\).
</p>

</div>

<p>
Om vi har vektorene representert på koordinatform, er det en enkel sak å regne ut skalarproduktet. Vi kan da bruke at 
</p>

\begin{aligned}
\vec{u}\cdot\vec{v} &= \left[u_x, u_y\right]\cdot\left[v_x, v_y\right] \\
                    &= u_x v_x + u_y v_y
\end{aligned}

<div class="task" id="org326599e">
<p>
Lag et program som tar inn to vektorer på koordinatform i lister. Regn ut vektorenes skalarprodukt ved å bruke definisjonen over.
</p>

<p>
Du kan for eksempel ta utgangspunkt i følgende:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">u</span> = [-5, 8]
<span class="org-variable-name">v</span> = [-3, 1]
</pre>
</div>

</div>

<p>
Skalarproduktet oppstår i mange områder av matematikken. I <code>numpy</code> har vi det innebygd som <code>dot</code>-funksjonen. For eksempel vil <code>np.dot(a, b)</code> regne ut skalarproduktet (eller «prikkproduktet» eller «dotproduktet») til de to vektorene <code>a</code> og <code>b</code>.
</p>

<div class="task" id="orgfb54d31">
<p>
Lag et program som tar inn to vektorer på koordinatform i numpy-arrayer. Regn ut vektorenes skalarprodukt ved å bruke <code>np.dot</code>.
</p>

<p>
Du kan for eksempel ta utgangspunkt i følgende:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">u</span> = np.array([-5, 8])
<span class="org-variable-name">v</span> = np.array([-3, 1])
</pre>
</div>

</div>
</div>
</div>

<div id="outline-container-org35bede0" class="outline-3">
<h3 id="org35bede0">Skalering eller skalarmultiplikasjon</h3>
<div class="outline-text-3" id="text-org35bede0">
<p>
Ordet «skalar» brukes ofte om tall i vektorsammenheng. Bakgrunnen for dette navnet er nettopp at et tall multiplisert med en vektor gir en <i>skalert</i> vektor. Vi kan bruke ordene «skalar» og «tall» om hverandre.
</p>

<p>
En vektor \(\vec{v}\) skalert med et tall \(t\) er en ny vektor med samme retning som \(\vec{v}\) og lengde \(t|\vec{v}|\).
</p>


<div id="org0875bba" class="figure">
<p><object type="image/svg+xml" data="figurer/vektor8.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 9 </span>Skalerte vektorer</p>
</div>

<p>
Her er \(0 < a < 1\), \(b > 1\) og \(c < 0\). Vi ser altså at en negativ skalering av en vektor gir en vektor med motsatt retning. For eksemplene i figuren over, er \(|b| = |c|\).
</p>

<div class="task" id="org33e7e5a">
<p>
Undersøk om <code>np.dot(t, v)</code> fungerer som forventet dersom <code>t</code> er et tall og <code>v</code> er en vektor i form av et numpy-array.
</p>

</div>
</div>
</div>
</div>

<div id="outline-container-partikler" class="outline-2">
<h2 id="partikler">Partikler</h2>
<div class="outline-text-2" id="text-partikler">
<p>

</p>
</div>

<div id="outline-container-orgf2ec62d" class="outline-3">
<h3 id="orgf2ec62d">Introduksjon</h3>
<div class="outline-text-3" id="text-orgf2ec62d">
<p>
Vi skal ha partikler sprettende rundt på en skjerm. Vi bør da kunne ha en måte i programmet vårt for å si «dette er en bestemt partikkel». Ideelt sett kunne for eksempel <code>partikkel_1</code> vist til en partikkel med en posisjon, fart, størrelse, og <code>partikkel_2</code> det samme.
</p>


<div id="org59b5fb3" class="figure">
<p><object type="image/svg+xml" data="figurer/partikkel1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 10 </span>To ulike partikler, <code>partikkel_1</code> og <code>partikkel_2</code></p>
</div>

<p>
Her ser vi at det som skiller <code>partikkel_1</code> og <code>partikkel_2</code> er deres <i>posisjon</i>, <i>mønster</i>, og <i>størrelse</i>. Vi må altså nok en gang gjøre et valg for hvordan vi skal representere partiklene i kode.
</p>

<p>
La oss si vi velger å ha <i>posisjon</i> som en liste med \(x\)- og \(y\)-verdier, <i>mønster</i> som en tekststreng (for eksempel <code>"stripete"</code> og <code>"prikkete"</code> og størrelse som et tall. Vi kunne da bestemt oss for at de to partiklene over var definert som
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">partikkel_1</span> = [[38.6, 8.6], <span class="org-string">"stripete"</span>, 13.5]
<span class="org-variable-name">partikkel_2</span> = [[87.3, -12.9], <span class="org-string">"prikkete"</span>, 8.3]
</pre>
</div>

<p>
Vi kan da fortelle de som skal bruke programmet at «en partikkel er en liste med tre verdier, den første verdien er en liste med koordinater, den andre en tekststreng som setter mønsteret, den tredje et tall for radiusen».
</p>

<div class="task" id="org0e79544">
<p>
Lag en <code>partikkel_3</code>, med radius 15.3, senter i origo og rutete mønster.
</p>

</div>

<p>
Python har en annen god datatype for å samle slike egenskaper, såkalte <i>dictionaries</i> eller ordbøker. Dette er en samling med nøkkelord og verdier. Om vi skulle oppgitt partiklene over som ordbøker, ville vi skrevet
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">partikkel_1</span> = {<span class="org-string">"posisjon"</span>: [38.6, 8.6],
               <span class="org-string">"m&#248;nster"</span>: <span class="org-string">"stripete"</span>,
               <span class="org-string">"radius"</span>: 13.5}
</pre>
</div>

<p>
Vi skriver altså <code>{}</code> med en samling av <code>nøkkelord: verdi,</code> mellom. Vi kan da hente ut verdier ved å skrive for eksempel <code>partikkel_1["radius"]</code> eller legge til nye verdier ved å skrive <code>partikkel_1["masse"] = 14</code>.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">print</span>(partikkel_1[<span class="org-string">"radius"</span>])
<span class="org-variable-name">partikkel_1</span>[<span class="org-string">"masse"</span>] = 14
<span class="org-keyword">print</span>(partikkel_1)
</pre>
</div>

<pre class="example" id="org81c9fd7">
13.5
{'posisjon': [38.6, 8.6], 'mønster': 'stripete', 'radius': 13.5, 'masse': 14}
</pre>

<div class="task" id="org8ff9c3f">
<p>
Lag <code>partikkel_1</code> og <code>partikkel_2</code> som over, men gjør posisjonen til et numpy-array, istedenfor lista vi bruker over.
</p>

</div>
</div>
</div>

<div id="outline-container-org66b7d6f" class="outline-3">
<h3 id="org66b7d6f">Tegne partikkel</h3>
<div class="outline-text-3" id="text-org66b7d6f">
<p>
Dette avsnittet forutsetter at du har lagt inn biblioteket <code>pygame</code>. Dette kan du gjøre ved å åpne programmet «Anaconda prompt» og kjøre kommandoen <code>pip install pygame</code>.
</p>

<p>
Pygame er et bibliotek som egentlig er ment for spill, men vi kan med hell bruke det for å visualisere fysikkmotoren vår òg.
</p>

<p>
De fleste spill følger en løkke som ser omtrent slikt ut:
</p>
<ol class="org-ol">
<li>Vi prosesserer data fra brukeren (tastetrykk, musebevegelser, stenge vinduet, osv.)</li>
<li>Spillmotoren oppdaterer spillet (partikler flyttes, lyder gjøres klare til å spilles av, osv.)</li>
<li>Et nytt bilde tegnes på skjermen (nye partikkelposisjoner, for eksempel.)</li>
</ol>

<p>
Før dette må vi initialisere hele «spillet».
</p>


<div id="orgcada47b" class="figure">
<p><object type="image/svg+xml" data="figurer/flytskjema1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
<p><span class="figure-number">Illustrasjon 11 </span>Flytskjema for hele «spillet» vårt</p>
</div>
</div>

<div id="outline-container-orgc9d1530" class="outline-4">
<h4 id="orgc9d1530">«Init» og oppsett</h4>
<div class="outline-text-4" id="text-orgc9d1530">
<p>
Her skal vi gjøre <code>pygame</code> klart.
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> pygame

pygame.init()
<span class="org-variable-name">flate</span> = pygame.display.set_mode((800, 600))

<span class="org-comment-delimiter"># </span><span class="org-comment">Her kommer vi til &#229; skrive &#248;vrige funksjonsdefinisjoner</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">og lage variabler til programmet v&#229;rt</span>
</pre>
</div>

<p>
Vi har nå gjort pygame klart til å bruke et vindu som er 800 piksler bredt, og 600 piksler høyt. Det er dette vinduet vi skal tegne partiklene våre i.
</p>
</div>
</div>

<div id="outline-container-orgb8f2132" class="outline-4">
<h4 id="orgb8f2132">Hovedløkke og prosessere inndata</h4>
<div class="outline-text-4" id="text-orgb8f2132">
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">kjoerer</span> = <span class="org-constant">True</span>
<span class="org-keyword">while</span> kjoerer:
    <span class="org-keyword">for</span> event <span class="org-keyword">in</span> pygame.event.get():
        <span class="org-keyword">if</span> event.<span class="org-builtin">type</span> == pygame.QUIT:
            <span class="org-variable-name">kjoerer</span> = <span class="org-constant">False</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Her kommer &#171;mainloopen&#187; v&#229;r</span>

<span class="org-keyword">print</span>(<span class="org-string">"Simuleringen er ferdig."</span>)
pygame.<span class="org-constant">quit</span>()
</pre>
</div>

<pre class="example">
Simuleringen er ferdig.
</pre>


<p>
Denne snutten gjør klar en hovedløkke, og vi setter opp et trinn for å prosessere inndata. Pygame håndterer handlinger fra brukeren ved å samle dem som =event=s.
</p>

<p>
Vi får tak i alle disse hendelsene («event») ved å kalle funksjonen <code>pygame.EVENT.get</code>. Dette gir oss en liste med hendelser. Vi kan så løpe gjennom hver av disse hendelsene (det kan for eksempel være flyttinga av musepekeren, trykking av knapper, osv.).
</p>

<p>
Dersom du har forsøkt å lukke pygame-vinduet, har en av hendelsene vært av typen <code>pygame.QUIT</code>. Vi sier da at dersom en av hendelsen var <code>pygame.QUIT</code> skal vi ut av hovedløkka, som vi her har valgt å gjøre ved å sette <code>kjoerer</code> til <code>False</code>.
</p>

<p>
Når vi da har kommet oss helt ut av hovedløkka vår (<code>while kjoerer</code>-blokka), stenger vi pygame ved å kalle <code>quit</code>-funksjonen.
</p>
</div>
</div>

<div id="outline-container-org653bd80" class="outline-4">
<h4 id="org653bd80">Oppdatere spilldata</h4>
<div class="outline-text-4" id="text-org653bd80">
<p>
Det har ikke skjedd så mye med partiklene våre ennå.
</p>

<p>
Om vi lager en partikkel som over, med
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">partikkel</span> = {<span class="org-string">"posisjon"</span>: [38.6, 8.6],
             <span class="org-string">"farge"</span>: (0, 14, 200),
             <span class="org-string">"radius"</span>: 14}
</pre>
</div>

<p>
kan vi nå late som at vi gjør noe med partikkelens posisjon hver gang gjennom løkka ved for eksempel å skrive
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> pygame

pygame.init()
<span class="org-variable-name">flate</span> = pygame.display.set_mode((800, 600))

<span class="org-variable-name">partikkel</span> = {<span class="org-string">"posisjon"</span>: [38.6, 8.6],
             <span class="org-string">"farge"</span>: (0, 14, 200),
             <span class="org-string">"radius"</span>: 14}


<span class="org-variable-name">kjoerer</span> = <span class="org-constant">True</span>
<span class="org-keyword">while</span> kjoerer:
    <span class="org-keyword">for</span> event <span class="org-keyword">in</span> pygame.event.get():
        <span class="org-keyword">if</span> event.<span class="org-builtin">type</span> == pygame.QUIT:
            <span class="org-variable-name">kjoerer</span> = <span class="org-constant">False</span>

    <span class="org-variable-name">partikkel</span>[<span class="org-string">"posisjon"</span>] = [38.6, 8.6]   <span class="org-comment-delimiter"># </span><span class="org-comment">Obs! Denne gj&#248;r ikke noe</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">!</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">!</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">! Se under</span>
    flate.fill((0, 0, 0))
    pygame.draw.circle(flate, (0, 14, 200), [38.6, 8.6], 14)
    pygame.display.flip()

<span class="org-keyword">print</span>(<span class="org-string">"Simuleringen er ferdig."</span>)
pygame.<span class="org-constant">quit</span>()
</pre>
</div>

<pre class="example">
Simuleringen er ferdig.
</pre>


<p>
Vi har dog fremdeles ikke en partikkel på skjermen. Dette kan vi fikse ved først å tegne en bakgrunn, for så å tegne en sirkel.
</p>

<p>
Om du erstatter de tre linjene med <code># !</code> med de følgende tre linjene, skal du nå få en partikkel opp på skjermen.
</p>

<div class="org-src-container">
<pre class="src src-python">flate.fill((0, 0, 0))  <span class="org-comment-delimiter"># </span><span class="org-comment">bakgrunn</span>
pygame.draw.circle(flate, (0, 14, 200), [38.6, 8.6], 14) <span class="org-comment-delimiter"># </span><span class="org-comment">partikkel</span>
pygame.display.flip()  <span class="org-comment-delimiter"># </span><span class="org-comment">sender alt til flaten</span>
</pre>
</div>

<p>
Vi kjører koden og får følgende:
</p>


<div id="org69b586b" class="figure">
<p><img src="figurer/partikkel_pygame.png" alt="partikkel_pygame.png" />
</p>
<p><span class="figure-number">Illustrasjon 12 </span>Vår første partikkel</p>
</div>

<p>
Vi merker oss at posisjonen var i et annet hjørne enn forventet, men lar det være med det inntil videre.
</p>

<div class="task" id="org3478c0f">
<p>
Du har lagt merke til at vi har vært uelegente med hvordan vi henter ut data fra partikkelen vår. Når vi tegner den, skriver vi for eksempel <code>(0, 14, 200)</code> for fargen, istedenfor <code>partikkel["farge"]</code>.
</p>

<p>
Fiks opp i dette slik at de ulike tallene kun står en gang i programmet.
</p>

</div>

<div class="task" id="org311bb60">
<p>
For å sette farge på partikkelen, har vi gitt fargen som en samling av r(ød)-, g(rønn)-, og b(lå)-verdier.
</p>

<p>
Du kan bruke <a href="https://htmlcolorcodes.com/color-picker/">denne</a> siden til å finne noen farger du liker. Velg ulike farger for partikkelen og bakgrunnen.
</p>

</div>

<div class="task" id="org147d6fb">
<p>
Bruk <code>randint</code>-funksjonen fra <code>random</code>-biblioteket til å gi partikkelen tilfeldig posisjon, farge og radius.
</p>

<p>
Hvordan kan du forsikre deg om at <i>hele</i> partikkelen alltid vises?
</p>

</div>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
